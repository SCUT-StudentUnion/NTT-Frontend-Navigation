<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JavaScript基础 | NTT Front-end Navigation</title>
    <meta name="description" content="网络队前端技术导航">
    
    
    <link rel="preload" href="/NTT-Frontend-Navigation.github.io/assets/css/0.styles.197cc9d4.css" as="style"><link rel="preload" href="/NTT-Frontend-Navigation.github.io/assets/js/app.f231f552.js" as="script"><link rel="preload" href="/NTT-Frontend-Navigation.github.io/assets/js/6.899d55bc.js" as="script"><link rel="preload" href="/NTT-Frontend-Navigation.github.io/assets/js/2.d922ff4b.js" as="script"><link rel="prefetch" href="/NTT-Frontend-Navigation.github.io/assets/js/10.885b55a2.js"><link rel="prefetch" href="/NTT-Frontend-Navigation.github.io/assets/js/3.7c8f5276.js"><link rel="prefetch" href="/NTT-Frontend-Navigation.github.io/assets/js/4.45dd3fad.js"><link rel="prefetch" href="/NTT-Frontend-Navigation.github.io/assets/js/5.3af3625e.js"><link rel="prefetch" href="/NTT-Frontend-Navigation.github.io/assets/js/7.37e2af67.js"><link rel="prefetch" href="/NTT-Frontend-Navigation.github.io/assets/js/8.af804ade.js"><link rel="prefetch" href="/NTT-Frontend-Navigation.github.io/assets/js/9.2da36c20.js">
    <link rel="stylesheet" href="/NTT-Frontend-Navigation.github.io/assets/css/0.styles.197cc9d4.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/NTT-Frontend-Navigation.github.io/" class="home-link router-link-active"><!----> <span class="site-name">NTT Front-end Navigation</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/NTT-Frontend-Navigation.github.io/" class="nav-link">主页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Mainline</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/NTT-Frontend-Navigation.github.io/Mainline/coding-intro.html" class="nav-link">引言</a></li><li class="dropdown-item"><!----> <a href="/NTT-Frontend-Navigation.github.io/Mainline/Concept-Basic.html" class="nav-link">基本概念</a></li><li class="dropdown-item"><!----> <a href="/NTT-Frontend-Navigation.github.io/Mainline/HTML-Basic.html" class="nav-link">HTML基础</a></li><li class="dropdown-item"><!----> <a href="/NTT-Frontend-Navigation.github.io/Mainline/CSS-Basic.html" class="nav-link">CSS基础</a></li><li class="dropdown-item"><!----> <a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html" class="nav-link router-link-exact-active router-link-active">JS基础</a></li><li class="dropdown-item"><!----> <a href="/NTT-Frontend-Navigation.github.io/Mainline/Typescript-Basic.html" class="nav-link">TS基础</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/NTT-Frontend-Navigation.github.io/" class="nav-link">主页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Mainline</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/NTT-Frontend-Navigation.github.io/Mainline/coding-intro.html" class="nav-link">引言</a></li><li class="dropdown-item"><!----> <a href="/NTT-Frontend-Navigation.github.io/Mainline/Concept-Basic.html" class="nav-link">基本概念</a></li><li class="dropdown-item"><!----> <a href="/NTT-Frontend-Navigation.github.io/Mainline/HTML-Basic.html" class="nav-link">HTML基础</a></li><li class="dropdown-item"><!----> <a href="/NTT-Frontend-Navigation.github.io/Mainline/CSS-Basic.html" class="nav-link">CSS基础</a></li><li class="dropdown-item"><!----> <a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html" class="nav-link router-link-exact-active router-link-active">JS基础</a></li><li class="dropdown-item"><!----> <a href="/NTT-Frontend-Navigation.github.io/Mainline/Typescript-Basic.html" class="nav-link">TS基础</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>JavaScript基础</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#数据类型" class="sidebar-link">数据类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#number" class="sidebar-link">Number</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#string" class="sidebar-link">String</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#boolean" class="sidebar-link">Boolean</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#null-undefined" class="sidebar-link">null&amp;undefined</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#object" class="sidebar-link">Object</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#array" class="sidebar-link">Array</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#date" class="sidebar-link">Date</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#map-set" class="sidebar-link">Map&amp;Set</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#function" class="sidebar-link">Function</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#symbol" class="sidebar-link">Symbol</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#bigint" class="sidebar-link">BigInt</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#typeof-instanceof" class="sidebar-link">typeof&amp;instanceof</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#动态类型-类型转换" class="sidebar-link">动态类型&amp;类型转换</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#基本类型-基本类型包装" class="sidebar-link">基本类型&amp;基本类型包装</a></li></ul></li><li><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#变量声明-declaration" class="sidebar-link">变量声明 Declaration</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#var" class="sidebar-link">var</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#let-const" class="sidebar-link">let&amp;const</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#命名规范" class="sidebar-link">命名规范</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#函数声明" class="sidebar-link">函数声明</a></li></ul></li><li><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#运算符" class="sidebar-link">运算符</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#比较运算符-与" class="sidebar-link">比较运算符 ==与===</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#与-运算符" class="sidebar-link">'与'运算符 &amp;&amp;</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#或-运算符" class="sidebar-link">'或'运算符 ||</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#扩展运算符" class="sidebar-link">扩展运算符 ...</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#基本运算" class="sidebar-link">基本运算 + - * /</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#方括号" class="sidebar-link">方括号 []</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#点运算符" class="sidebar-link">点运算符 .</a></li></ul></li><li><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#关键字" class="sidebar-link">关键字</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#new" class="sidebar-link">new</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#delete" class="sidebar-link">delete</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#throw" class="sidebar-link">throw</a></li></ul></li><li><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#循环体" class="sidebar-link">循环体</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#foreach" class="sidebar-link">forEach</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#for…in" class="sidebar-link">for…in</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#for…of" class="sidebar-link">for…of</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#iterable接口" class="sidebar-link">iterable接口</a></li></ul></li><li><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#内置对象" class="sidebar-link">内置对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#math" class="sidebar-link">Math</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#json" class="sidebar-link">JSON</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#date-2" class="sidebar-link">Date</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#regexp" class="sidebar-link">RegExp</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#array-2" class="sidebar-link">Array</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#string-2" class="sidebar-link">String</a></li></ul></li><li><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#函数简介" class="sidebar-link">函数简介</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#this" class="sidebar-link">this</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#绑定this" class="sidebar-link">绑定this</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#this与函数" class="sidebar-link">this与函数</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#实现bind" class="sidebar-link">实现bind</a></li></ul></li><li><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#作用域-scope" class="sidebar-link">作用域 Scope</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#变量作用域" class="sidebar-link">变量作用域</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#作用域链-scope-chain" class="sidebar-link">作用域链 Scope Chain</a></li></ul></li><li><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#数组-array" class="sidebar-link">数组 Array</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#属性" class="sidebar-link">属性</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#变异方法与非变异方法-mutation-method-and-non-mutation-method" class="sidebar-link">变异方法与非变异方法 mutation method and non-mutation method</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#map" class="sidebar-link">map</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#foreach-2" class="sidebar-link">forEach</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#reduce" class="sidebar-link">reduce</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#reduceright" class="sidebar-link">reduceRight</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#filter" class="sidebar-link">filter</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#push、pop" class="sidebar-link">push、pop</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#shift、unshift" class="sidebar-link">shift、unshift</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#slice" class="sidebar-link">slice</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#find" class="sidebar-link">find</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#findindex" class="sidebar-link">findIndex</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#indexof" class="sidebar-link">indexOf</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#lastindexof" class="sidebar-link">lastIndexOf</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#sort" class="sidebar-link">sort</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#reverse" class="sidebar-link">reverse</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#splice" class="sidebar-link">splice</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#concat" class="sidebar-link">concat</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#join" class="sidebar-link">join</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#fill" class="sidebar-link">fill</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#copywithin" class="sidebar-link">copyWithin</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#includes" class="sidebar-link">includes</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#from" class="sidebar-link">from</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#every" class="sidebar-link">every</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#some" class="sidebar-link">some</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#entries" class="sidebar-link">entries</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#keys" class="sidebar-link">keys</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#isarray" class="sidebar-link">isArray</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#tostring" class="sidebar-link">toString</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#valueof" class="sidebar-link">valueOf</a></li></ul></li><li><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#对象" class="sidebar-link">对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#可枚举属性-enumerable-properties" class="sidebar-link">可枚举属性 Enumerable Properties</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#对象拷贝" class="sidebar-link">对象拷贝</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#object-assign" class="sidebar-link">Object.assign()</a></li></ul></li><li><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#原型-prototype" class="sidebar-link">原型 Prototype</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#string方法" class="sidebar-link">String方法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#substring" class="sidebar-link">substring</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#substr" class="sidebar-link">substr</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#trim" class="sidebar-link">trim</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#split" class="sidebar-link">split</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#slice-2" class="sidebar-link">slice</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#replace" class="sidebar-link">replace</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#match" class="sidebar-link">match</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#search" class="sidebar-link">search</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#indexof-2" class="sidebar-link">indexOf</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#lastindexof-2" class="sidebar-link">lastIndexOf</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#includes-2" class="sidebar-link">includes</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#concat-2" class="sidebar-link">concat</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#tolowercase" class="sidebar-link">toLowerCase</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#touppercase" class="sidebar-link">toUpperCase</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#repeat" class="sidebar-link">repeat</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#startswith" class="sidebar-link">startsWith</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#charat" class="sidebar-link">charAt</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#charcodeat" class="sidebar-link">charCodeAt</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#fromcharcode" class="sidebar-link">fromCharCode</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#html包装方法" class="sidebar-link">HTML包装方法</a></li></ul></li><li><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#错误处理" class="sidebar-link">错误处理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#try-catch" class="sidebar-link">try...catch</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#throw-2" class="sidebar-link">throw</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#finally" class="sidebar-link">finally</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#error对象" class="sidebar-link">Error对象</a></li></ul></li><li><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#参考" class="sidebar-link">参考</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#模板字符串" class="sidebar-link">模板字符串</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#变量作用域-2" class="sidebar-link">变量作用域</a></li></ul></li><li><a href="/NTT-Frontend-Navigation.github.io/Mainline/Javascript-Basic.html#参考目录" class="sidebar-link">参考目录</a><ul class="sidebar-sub-headers"></ul></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="javascript基础"><a href="#javascript基础" aria-hidden="true" class="header-anchor">#</a> JavaScript基础</h1> <p>用看得懂的话写de教程。</p> <h2 id="数据类型"><a href="#数据类型" aria-hidden="true" class="header-anchor">#</a> 数据类型</h2> <p>JavaScript的原始数据类型包括Number、String、Boolean、Null、Undefined、Symbol（ES6新增）、BigInt（最近新增），此外有Object类型。</p> <h3 id="number"><a href="#number" aria-hidden="true" class="header-anchor">#</a> Number</h3> <p>不区分整数和浮点，注意浮点计算结果是不精确的（由于浮点数的计算方式），对浮点数不建议直接用等号判断两值相等，应当看他们的差是否小于某个值（如0.001）。Infinity（超过Number最大值）、NaN（Not a Number）也是合法的Number。</p> <div class="tip custom-block"><p class="custom-block-title">关于NaN</p> <p>NaN是特殊的Number，它也不等于自己，只能通过isNaN()判断。</p></div> <h3 id="string"><a href="#string" aria-hidden="true" class="header-anchor">#</a> String</h3> <p>单引号‘’或双引号&quot;&quot;包裹的字符串。</p> <h3 id="boolean"><a href="#boolean" aria-hidden="true" class="header-anchor">#</a> Boolean</h3> <p>Boolean包括'true'、'false'两种取值。比较运算符、&amp;&amp;、||与!都会产生布尔值。</p> <div class="tip custom-block"><p class="custom-block-title">转换结果为false的取值</p> <p>NaN、null、undefined、0与空字符串转Boolean的结果都为false。</p></div> <h3 id="null-undefined"><a href="#null-undefined" aria-hidden="true" class="header-anchor">#</a> null&amp;undefined</h3> <p>null表示空值，undefined表示未赋值，undefined可以用于判断函数参数是否传递。他们是两种数据类型。</p> <div class="warning custom-block"><p class="custom-block-title">null和undefined的注意事项</p> <ol><li><p>null是保留字，而undefined不是。</p></li> <li><p>如果访问不存在的变量，会报错&quot;var is not defined&quot;；访问已声明但未赋值的变量才会得到undefined。</p></li> <li><p>typeof null的结果是object，但null也是一种基本类型而非object，这个混淆是由于typeof以内存低位判断数据类型，object和null的低3位都是0。</p></li></ol></div> <h3 id="object"><a href="#object" aria-hidden="true" class="header-anchor">#</a> Object</h3> <p>键-值对的无序集合。键（key）只能是字符串类型，值（value）可以是任意类型。'.'可以用于表示键路径，比如obj.key或obj.obj.a。</p> <p>Object是引用类型，存储的是指针，而其他基本类型存储值。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>key<span class="token punctuation">:</span><span class="token string">'value'</span><span class="token punctuation">,</span>
           obj<span class="token punctuation">:</span><span class="token punctuation">{</span>
             a<span class="token punctuation">:</span><span class="token string">'a'</span>
           <span class="token punctuation">}</span><span class="token punctuation">}</span>
</code></pre></div><h3 id="array"><a href="#array" aria-hidden="true" class="header-anchor">#</a> Array</h3> <p>用[]或new Array()创建，数组可以包含任意类型元素并且提供了相当多的方法。Array属于Object类型。</p> <h3 id="date"><a href="#date" aria-hidden="true" class="header-anchor">#</a> Date</h3> <p>Date类型提供了丰富的与时间、日期相关的方法，Date()返回当前日期的字符串。Date也属于Object类型。</p> <h3 id="map-set"><a href="#map-set" aria-hidden="true" class="header-anchor">#</a> Map&amp;Set <span class="badge tip top" data-v-74aba598>ES6</span></h3> <p>ES6新增的数据结构。</p> <p>Map是一组key-value对结构，key不能重复，否则只保留最新的值。与对象只支持string与symbol相比，Map 的key支持任意类型。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> students <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'Lucy'</span><span class="token punctuation">,</span><span class="token number">90</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'Peter'</span><span class="token punctuation">,</span><span class="token number">80</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'Bill'</span><span class="token punctuation">,</span><span class="token number">85</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
students<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'Lucy'</span><span class="token punctuation">)</span><span class="token comment">//90</span>
students<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token string">'Peter'</span><span class="token punctuation">)</span><span class="token comment">//true</span>
students<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">'Peter'</span><span class="token punctuation">)</span><span class="token comment">//true</span>
students<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'Peter'</span><span class="token punctuation">)</span><span class="token comment">//undefined</span>
students<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">'Bill'</span><span class="token punctuation">,</span><span class="token number">90</span><span class="token punctuation">)</span><span class="token comment">//Map { 'Lucy' =&gt; 90, 'Bill' =&gt; 90 }</span>
students<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'Bill'</span><span class="token punctuation">)</span><span class="token comment">//90</span>
</code></pre></div><p>Set类似集合，由一组不重复的key组成，否则只保留一个。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> foods <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'Chicken'</span><span class="token punctuation">,</span><span class="token string">'Noodles'</span><span class="token punctuation">,</span><span class="token string">'Rice'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
foods<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'fish'</span><span class="token punctuation">)</span><span class="token comment">//Set { 'Chicken', 'Noodles', 'Rice', 'fish' }</span>
foods<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">'Noodles'</span><span class="token punctuation">)</span><span class="token comment">//true</span>
foods<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token string">'Rice'</span><span class="token punctuation">)</span><span class="token comment">//true</span>
</code></pre></div><h3 id="function"><a href="#function" aria-hidden="true" class="header-anchor">#</a> Function</h3> <p>有趣的是，函数是Object的实例，而Object也是函数的实例。</p> <h3 id="symbol"><a href="#symbol" aria-hidden="true" class="header-anchor">#</a> Symbol <span class="badge tip top" data-v-74aba598>ES6</span></h3> <p>用于产生唯一标识，除了自己等于自己，两个完全相同的symbol不相等，常用于对象属性、声明唯一常量、定义私有属性。也可以用Symbol.for()创建symbol，如果参数一致，创建的symbol相等。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span>
s <span class="token operator">==</span> s1<span class="token comment">//false</span>
s <span class="token operator">===</span> s<span class="token comment">//true</span>
<span class="token keyword">let</span> s2 <span class="token operator">=</span> Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> s3 <span class="token operator">=</span> Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span>
s2 <span class="token operator">==</span> s3<span class="token comment">//true</span>
</code></pre></div><p>你可以通过以下方式获取Symbol的description（无需记忆）。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> s2 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">&quot;love&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">[</span>s2<span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token string">&quot;and peace&quot;</span><span class="token punctuation">}</span>
obj<span class="token comment">//{ [Symbol(love)]: 'and peace' }</span>
Object<span class="token punctuation">.</span><span class="token function">getOwnPropertySymbols</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token comment">//[ Symbol(love) ]</span>
Reflect<span class="token punctuation">.</span><span class="token function">ownKeys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token comment">//[ Symbol(love) ]</span>
</code></pre></div><p>Symbol定义了对象的许多实用方法，包括[Symbol.Iterator]、[Symbol.match]、[Symbol.replace]、[Symbol.split]、[Symbol.toPrimitive]、[Symbol.toStringTag]等。toStringTag方法甚至能改变对象的toString方法。</p> <h3 id="bigint"><a href="#bigint" aria-hidden="true" class="header-anchor">#</a> BigInt <span class="badge tip top" data-v-74aba598>ES6</span></h3> <p>在数字末尾加n可声明BigInt，其可操作大于Number所能表示最大数的数（2^53）。该类型尚在提案过程中，在新版Chrome与Node中得到实现。</p> <p>带小数的运算会被取整。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> Num <span class="token operator">=</span> <span class="token function">BigInt</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">63</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> Num2 <span class="token operator">=</span> <span class="token number">100n</span>
</code></pre></div><h3 id="typeof-instanceof"><a href="#typeof-instanceof" aria-hidden="true" class="header-anchor">#</a> typeof&amp;instanceof</h3> <p>typeof返回字符串有以下结果“number”、“string”、“boolean”、“object”、“function”、“undefined”、“symbol”，null打印为“object”。而instanceof用于判断检测对象的类型，包括&quot;Array&quot;、&quot;Function&quot;、&quot;Object&quot;及自定义类/构造函数等。</p> <p>此外Object.prototype.toString.call()可以准确打印出Null的类型。也可以通过访问&quot;.constructor&quot;获取构造函数判断类型。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">typeof</span> a<span class="token comment">//'object'</span>
a <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token comment">//true</span>

<span class="token keyword">class</span> <span class="token class-name">y</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">let</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
t <span class="token keyword">instanceof</span> <span class="token class-name">y</span><span class="token comment">//true</span>
</code></pre></div><h3 id="动态类型-类型转换"><a href="#动态类型-类型转换" aria-hidden="true" class="header-anchor">#</a> 动态类型&amp;类型转换</h3> <p>作为动态语言，JS允许同一个变量在不同时间用作不同类型。</p> <h4 id="使用javascript函数转换"><a href="#使用javascript函数转换" aria-hidden="true" class="header-anchor">#</a> 使用JavaScript函数转换</h4> <p>例如全局方法（构造函数）String()、Number()、Date()以及变量的toString()方法等。不同类型还会有独有的方法比如Date变量的getDate()、getDay()，Number变量的toPrecision()等。</p> <h4 id="使用javascript自动转换"><a href="#使用javascript自动转换" aria-hidden="true" class="header-anchor">#</a> 使用JavaScript自动转换</h4> <p>变量类型会根据需要发生类型转换，例如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">5</span> <span class="token operator">+</span> <span class="token keyword">null</span> <span class="token comment">//5 因为null=0</span>
<span class="token number">5</span> <span class="token operator">+</span> <span class="token keyword">undefined</span> <span class="token comment">//NaN 因为undefined转为数字是NaN</span>
<span class="token string">&quot;0&quot;</span><span class="token operator">+</span> <span class="token keyword">null</span> <span class="token comment">//&quot;0null&quot; 因为null=&quot;null&quot;</span>
<span class="token string">&quot;5&quot;</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token comment">//&quot;51&quot; 因为1=&quot;1&quot;</span>
<span class="token number">1</span> <span class="token operator">+</span> <span class="token string">&quot;5&quot;</span> <span class="token comment">//&quot;51&quot; 因为1=&quot;1&quot;</span>
<span class="token string">&quot;5&quot;</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token comment">//4 因为&quot;5&quot;=5</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token comment">//&quot;1,21&quot; 数组先转字符串，再加&quot;1&quot;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">&quot;str&quot;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">//这里的代码将会执行，因为“str”可以转为true</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以观察到含字符串类型会转为字符串，没有或不能转字符串的话转数字（除加号以外，结果转数字）。</p> <p>自动转换有一些基础规则，比如Boolean值的转换：true等于1，false等于0，空字符串、空数组和null等于0，非纯数字字符串转为NaN等。</p> <p>有趣的是，&quot;0&quot;可以转为Boolean的“true”，但“0”转为数字0之后再转Boolean就会变成“false”。空数组也可以转“true”，转数字之后也为0。</p> <h3 id="基本类型-基本类型包装"><a href="#基本类型-基本类型包装" aria-hidden="true" class="header-anchor">#</a> 基本类型&amp;基本类型包装</h3> <p>除了Object类型存储的是引用，所有类型都是基本类型（存储值），但除了null和undefined，他们都像对象一样拥有自己的方法。这不是因为基本类型具有方法，而是在调用基本类型的方法时，JS引擎自动包装了基本类型，调用结束后销毁对象。</p> <p>因此，向基本类型添加属性是无效的，因为添加完成后临时对象即被销毁，但可以向其原型添加属性和方法。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">'str'</span>
str<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">/*
相当于做了这些事
var _str = new String(str)
str = _str.toUpperCase()
*/</span>
</code></pre></div><h2 id="变量声明-declaration"><a href="#变量声明-declaration" aria-hidden="true" class="header-anchor">#</a> 变量声明 Declaration</h2> <h3 id="var"><a href="#var" aria-hidden="true" class="header-anchor">#</a> var</h3> <p>变量用var声明，不用var则作为全局变量。var声明的变量处于全局作用域或函数作用域。</p> <h4 id="变量提升-hoisting"><a href="#变量提升-hoisting" aria-hidden="true" class="header-anchor">#</a> 变量提升 Hoisting</h4> <p>用var声明的变量，可以在声明语句之前使用，但不会初始化（赋值）。因此访问他们虽然不会报错，但会得到undefined。</p> <h3 id="let-const"><a href="#let-const" aria-hidden="true" class="header-anchor">#</a> let&amp;const <span class="badge tip top" data-v-74aba598>ES6</span></h3> <p>ES6中新增了let与const关键字，分别代表块级作用域中的变量与常量，同时不允许重复声明，没有变量提升。</p> <h4 id="块级作用域"><a href="#块级作用域" aria-hidden="true" class="header-anchor">#</a> 块级作用域</h4> <p>由{}包裹的代码块。在for循环中，()与{}是父子块级作用域，也就是说{}用let或const声明的变量不会影响for循环计数。</p> <p>块级作用域没有变量提升，可以防止在函数内使用上级变量时，后面声明的变量意外覆盖上级变量。</p> <p>使用var声明变量：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> h<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span>
<span class="token keyword">var</span> h<span class="token punctuation">;</span><span class="token comment">//覆盖了上级变量</span>
<span class="token punctuation">}</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//undefined</span>
</code></pre></div><p>使用let声明变量：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> h<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token comment">//暂时性死区</span>
<span class="token keyword">let</span> h<span class="token punctuation">;</span><span class="token comment">//与当前作用域绑定，声明之前不可读取</span>
<span class="token punctuation">}</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//ReferenceError: Cannot access 'h' before initialization</span>
</code></pre></div><p>同时块间的隔离有助于减少冲突和出错。此前，JS只能用函数作用域来隔离变量，常用的方式就是匿名立即执行函数（匿名IIFE）。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> hours<span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">//等同于</span>
<span class="token punctuation">{</span><span class="token keyword">let</span> hours<span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">}</span>
</code></pre></div><div class="tip custom-block"><p class="custom-block-title">暂时性死区 temporal dead zone</p> <p>let和const声明的变量会与代码块绑定，在声明前不能使用同名的上级环境变量，否则会引发报错。</p></div> <h3 id="命名规范"><a href="#命名规范" aria-hidden="true" class="header-anchor">#</a> 命名规范</h3> <p>变量名由26字母的大小写、数字、“$“和”_“组成，不能用数字开头。甚至支持中文，但不建议使用，避免引发麻烦。</p> <h3 id="函数声明"><a href="#函数声明" aria-hidden="true" class="header-anchor">#</a> 函数声明</h3> <p>推荐使用函数表达式<code>let func=()=&gt;{}</code>或<code>let func=function(){}</code>为变量赋值，因此函数声明也遵循以上规则。如果用<code>function func(){}</code>直接声明函数，ES5中函数声明能完整地提升，ES6虽然规定了行为类似let，但实际可能会先赋值为undefined，不同环境可能有不同的处理。</p> <h2 id="运算符"><a href="#运算符" aria-hidden="true" class="header-anchor">#</a> 运算符</h2> <h3 id="比较运算符-与"><a href="#比较运算符-与" aria-hidden="true" class="header-anchor">#</a> 比较运算符 ==与===</h3> <p>==表示在类型转换后相等，===表示类型和值都一样。除非需要用到==的特性，否则建议用===比较。</p> <div class="tip custom-block"><p class="custom-block-title">比较对象</p> <p>对象的比较与原始值不同，比较的是引用，因此两个完全相同的数组不相等，除非他们是对同一处的引用。</p></div> <h3 id="与-运算符"><a href="#与-运算符" aria-hidden="true" class="header-anchor">#</a> '与'运算符 &amp;&amp;</h3> <p>‘与’运算符，如果左边表达式的值是false或可以转为false则返回左边表达式的值，否则返回右边表达式的值。</p> <p>Boolean角度：&amp;&amp;只有当两边都为true，结果才为true，如果左边结果为false，右边不会判断。</p> <h3 id="或-运算符"><a href="#或-运算符" aria-hidden="true" class="header-anchor">#</a> '或'运算符 ||</h3> <p>‘或’运算符，如果左边表达式的值是true或可以转为true则返回左边表达式的值，否则返回右边表达式的值。</p> <p>Boolean角度：||只有当两边都为false，结果才为false，如果左边结果为true，右边不会判断。</p> <h3 id="扩展运算符"><a href="#扩展运算符" aria-hidden="true" class="header-anchor">#</a> 扩展运算符 ... <span class="badge tip top" data-v-74aba598>ES6</span></h3> <p>ES6中的扩展运算符，用在数组或对象前表示取出所有项或属性。</p> <h4 id="用于对象"><a href="#用于对象" aria-hidden="true" class="header-anchor">#</a> 用于对象</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> obj<span class="token operator">=</span><span class="token punctuation">{</span>a<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span>b<span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">}</span>
<span class="token keyword">let</span> newObj<span class="token operator">=</span><span class="token punctuation">{</span><span class="token operator">...</span>obj<span class="token punctuation">,</span>c<span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token comment">//{ a: 1, b: 2, c: 3 }</span>
</code></pre></div><h4 id="用于数组"><a href="#用于数组" aria-hidden="true" class="header-anchor">#</a> 用于数组</h4> <h5 id="赋值"><a href="#赋值" aria-hidden="true" class="header-anchor">#</a> 赋值</h5> <p>生成数组的拷贝。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> arr<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> newArr<span class="token operator">=</span><span class="token punctuation">[</span><span class="token operator">...</span>arr<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token comment">//[ 0, 1, 2, 3, 4 ]</span>
<span class="token keyword">let</span> arr_copy<span class="token operator">=</span><span class="token punctuation">[</span><span class="token operator">...</span>arr<span class="token punctuation">]</span>
</code></pre></div><h5 id="解构赋值"><a href="#解构赋值" aria-hidden="true" class="header-anchor">#</a> 解构赋值</h5> <p>结合解构赋值，它还提供了生成数组的方法。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token punctuation">[</span><span class="token operator">...</span>arr_copy<span class="token punctuation">]</span><span class="token operator">=</span>arr

<span class="token keyword">let</span> <span class="token punctuation">[</span>ar1<span class="token punctuation">,</span><span class="token operator">...</span>ar2<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
ar1<span class="token comment">//0</span>
ar2<span class="token comment">//[ 1, 2, 3 ]</span>

<span class="token keyword">let</span> <span class="token punctuation">[</span><span class="token operator">...</span>ar3<span class="token punctuation">,</span>ar4<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token comment">//SyntaxError: Rest element must be last element</span>
</code></pre></div><div class="warning custom-block"><p class="custom-block-title">WARNING</p> <p>扩展运算符只能用在最后一项。</p></div> <h4 id="一个分号引发的血案"><a href="#一个分号引发的血案" aria-hidden="true" class="header-anchor">#</a> 一个分号引发的血案</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> val <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//;</span>
<span class="token punctuation">[</span>a<span class="token punctuation">,</span>b<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span>b<span class="token punctuation">,</span>a<span class="token punctuation">]</span> 或 <span class="token punctuation">[</span>a<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">,</span>b<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span>b<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre></div><p>如果缺少分号，JS解析会出现错误，原因是两行连在一起也符合语法规则。这种情况下</p> <h4 id="用于函数参数"><a href="#用于函数参数" aria-hidden="true" class="header-anchor">#</a> 用于函数参数</h4> <p>除了为数组赋值，还支持作为函数参数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> arr<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> a<span class="token operator">+</span>b
<span class="token punctuation">}</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">...</span>arr<span class="token punctuation">)</span><span class="token comment">//1</span>
</code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p> <p>任何含Iterator接口的对象都可以通过扩展运算符转为真正的数组。详情见<a href="#iterable%E6%8E%A5%E5%8F%A3">iterable接口</a>。</p></div> <h3 id="基本运算"><a href="#基本运算" aria-hidden="true" class="header-anchor">#</a> 基本运算 + - * /</h3> <p>可以用于各种类型间的运算。</p> <h3 id="方括号"><a href="#方括号" aria-hidden="true" class="header-anchor">#</a> 方括号 []</h3> <p>属性访问器。最常用的是表示数组<code>[1,2,3]</code>与数组下标<code>arr[1]</code>，也可以作为对象的属性名<code>obj['key']</code>，支持使用变量作为属性名<code>obj[key]</code>（key不仅可以是符合规则的字符串，也可以是Symbol）。</p> <h3 id="点运算符"><a href="#点运算符" aria-hidden="true" class="header-anchor">#</a> 点运算符 .</h3> <p>属性访问器。点运算符的功能是[]的子集，当属性名为常量时可以用于设置、获取对象属性<code>obj.key</code>。</p> <h2 id="关键字"><a href="#关键字" aria-hidden="true" class="header-anchor">#</a> 关键字</h2> <h3 id="new"><a href="#new" aria-hidden="true" class="header-anchor">#</a> new</h3> <p>从构造函数派生出对象，构造函数的this指向创建的对象。</p> <h3 id="delete"><a href="#delete" aria-hidden="true" class="header-anchor">#</a> delete</h3> <p>用于删除对象属性，不可用于删除对象。</p> <h3 id="throw"><a href="#throw" aria-hidden="true" class="header-anchor">#</a> throw</h3> <p>抛出异常。通常结合try...catch使用。</p> <h2 id="循环体"><a href="#循环体" aria-hidden="true" class="header-anchor">#</a> 循环体</h2> <h3 id="foreach"><a href="#foreach" aria-hidden="true" class="header-anchor">#</a> forEach</h3> <p><code>Array.prototype.forEach(function(currentValue, index, arr), thisValue)</code></p> <p>由于是以传入函数的形式遍历，forEach无法使用return从外部函数体返回，由于是数组的一种方法，也不支持break跳出循环。</p> <h3 id="for…in"><a href="#for…in" aria-hidden="true" class="header-anchor">#</a> for…in</h3> <p><code>for(let item in obj)</code></p> <p>for…in支持遍历各种对象，它的item是对象的key，总是string类型。这种方法不稳定，不同时候结果的顺序可能不一致。如果用于数组，还有一个问题是所有属性也包括数组元素以外的自定义属性。</p> <h3 id="for…of"><a href="#for…of" aria-hidden="true" class="header-anchor">#</a> for…of <span class="badge tip top" data-v-74aba598>ES6</span></h3> <p><code>for(let item of obj)</code></p> <p>首先，它没有for…in的缺点，其次，也没有forEach的缺点。for…of支持数组、字符串、Set、Map和其他有iterable接口的对象，但不支持普通对象（会提示<code>is not iterable</code>）。</p> <h3 id="iterable接口"><a href="#iterable接口" aria-hidden="true" class="header-anchor">#</a> iterable接口 <span class="badge tip top" data-v-74aba598>ES6</span></h3> <p>对象的<code>[Symbol.iterator]</code>属性指向其默认的遍历器，其不仅提供了统一的接口，还能按规定的顺序排列。在ES6中，Array、String、Set和Map、arguments等类数组对象都具有iterable接口。而<a href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">解构赋值</a>、<a href="#%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6">扩展运算符</a>、yield和任何与接受数组的场合都调用了Iterator接口。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> myIterable <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
myIterable<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">yield</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">yield</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">yield</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">[</span><span class="token operator">...</span>myIterable<span class="token punctuation">]</span><span class="token comment">//[ 1, 2, 3 ]</span>
</code></pre></div><p>借用数组的iterator：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> fakeArray<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token string">'apple'</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token string">'peach'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token string">'pancake'</span><span class="token punctuation">,</span>length<span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">,</span>
               <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">}</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> it <span class="token keyword">of</span> fakeArray<span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">//apple peach pancake</span>
</code></pre></div><p>待填坑 async写法、next()写法</p> <h2 id="内置对象"><a href="#内置对象" aria-hidden="true" class="header-anchor">#</a> 内置对象</h2> <h3 id="math"><a href="#math" aria-hidden="true" class="header-anchor">#</a> Math</h3> <h4 id="math-pow"><a href="#math-pow" aria-hidden="true" class="header-anchor">#</a> Math.pow()</h4> <h3 id="json"><a href="#json" aria-hidden="true" class="header-anchor">#</a> JSON</h3> <p>JSON不是JS，也用在很多其他语言中，作为一种简单的传递对象数据的格式。</p> <h4 id="json-parse"><a href="#json-parse" aria-hidden="true" class="header-anchor">#</a> JSON.parse()</h4> <p>将标准JSON格式的字符串转为JS对象，不符合格式会提示‘unexpected token'，最常见的是'unexpected token u'，也就是undefined，因此写接口一定要注意确定请求成功再转换对象。</p> <h4 id="json-stringify"><a href="#json-stringify" aria-hidden="true" class="header-anchor">#</a> JSON.stringify()</h4> <p>将JS对象转为JSON格式，结合parse可以用于对象深拷贝。</p> <h3 id="date-2"><a href="#date-2" aria-hidden="true" class="header-anchor">#</a> Date</h3> <h3 id="regexp"><a href="#regexp" aria-hidden="true" class="header-anchor">#</a> RegExp</h3> <h3 id="array-2"><a href="#array-2" aria-hidden="true" class="header-anchor">#</a> <a href="#%E6%95%B0%E7%BB%84-array">Array</a></h3> <h3 id="string-2"><a href="#string-2" aria-hidden="true" class="header-anchor">#</a> <a href="#string%E6%96%B9%E6%B3%95">String</a></h3> <h2 id="函数简介"><a href="#函数简介" aria-hidden="true" class="header-anchor">#</a> 函数简介</h2> <p>普通函数都是Function对象的实例，而构造函数生成的函数是Object的实例。相比普通对象，函数多了可被调用的特征。</p> <div class="tip custom-block"><p class="custom-block-title">'Function'与‘function’的不同</p> <p>‘Function’是JS的内置对象，而'function'是一个声明函数的关键字。</p></div> <div class="tip custom-block"><p class="custom-block-title">和其他语言函数的区别</p> <p>由于JS是弱类型语言，函数无法指定形参类型与返回类型，同时也无法限制传入参数的个数，因此没有重载的特性。函数内部可以通过<strong>arguments对象</strong>获取实参。</p></div> <h2 id="this"><a href="#this" aria-hidden="true" class="header-anchor">#</a> this</h2> <p>this指向调用当前函数的对象，如果没有对象调用，那么this==window。在箭头函数中，this指向与环境中相同。bind、call、reply方法都可以修改this。</p> <h3 id="绑定this"><a href="#绑定this" aria-hidden="true" class="header-anchor">#</a> 绑定this</h3> <p>绑定this的4种方法，按优先级从低到高排序分别是默认绑定、隐式绑定、显式绑定、new绑定。其中apply()与call()属于显式绑定。</p> <h4 id="默认绑定"><a href="#默认绑定" aria-hidden="true" class="header-anchor">#</a> 默认绑定</h4> <p>全局环境中、函数独立调用时（即使被嵌套、包括立即执行函数），this指向window。有时候被嵌套的函数想获得上层函数的this，可以使用<code>var that = this</code>语句传递this值。</p> <h4 id="隐式绑定-方法调用"><a href="#隐式绑定-方法调用" aria-hidden="true" class="header-anchor">#</a> 隐式绑定/方法调用</h4> <p>this的值是调用该函数的对象。如a.b()中b内部的this指向a。只有直接调用<code>obj.func()</code>时才会传递this，否则this仍指向window。函数虽然可以属于一个对象，但函数不会与对象绑定this。</p> <p>这些不能传递this的场景包括赋值、传参、内置函数（如setTimeout）、间接引用（对象的属性赋值时的立即执行函数，如<code>(p.foo = o.foo)()</code>，this为window）等。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> val<span class="token operator">=</span><span class="token string">'window'</span>
<span class="token keyword">var</span> <span class="token function-variable function">func</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>val<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> obj<span class="token operator">=</span><span class="token punctuation">{</span>val<span class="token punctuation">:</span><span class="token string">'obj'</span><span class="token punctuation">,</span>func<span class="token punctuation">:</span>func<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//window</span>
obj<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//obj</span>

<span class="token comment">//赋值会丢失this</span>
<span class="token keyword">var</span> func1 <span class="token operator">=</span> obj<span class="token punctuation">.</span>func
<span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//window</span>

<span class="token comment">//作为参数传递也会丢失this</span>
<span class="token keyword">var</span> <span class="token function-variable function">func2</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">func</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">func2</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>func<span class="token punctuation">)</span><span class="token comment">//window</span>
</code></pre></div><h4 id="显示绑定"><a href="#显示绑定" aria-hidden="true" class="header-anchor">#</a> 显示绑定</h4> <p>即使用call、apply、bind方法绑定this到对象上。JS还新增了许多内置函数提供thisValue选项，如数组的迭代方法map、forEach、filter、some、every。</p> <h4 id="new绑定"><a href="#new绑定" aria-hidden="true" class="header-anchor">#</a> new绑定</h4> <p>new的作用是从构造函数返回新对象。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">constructorA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token operator">=</span><span class="token number">0</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">constructorA</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
obj<span class="token punctuation">.</span>a<span class="token comment">//0</span>
</code></pre></div><p>需要注意如果constructor没有返回值，那么构造的对象就是返回值。而其中的this永远指向obj，即新生成的对象，即使<code>let newObj = new obj.constructorA()</code>，this也会指向newObj，而不是obj。</p> <h3 id="this与函数"><a href="#this与函数" aria-hidden="true" class="header-anchor">#</a> this与函数</h3> <p>this的四种绑定方法其实也对应函数的四种调用方式，包括函数调用(func)、方法调用（obj.func）、间接调用（call、apply）、构造函数调用（new）。</p> <h3 id="实现bind"><a href="#实现bind" aria-hidden="true" class="header-anchor">#</a> 实现bind</h3> <p><code>Function.prototype.bind(thisArg[,arg1[,arg2[,...]]])</code></p> <p>bind提供了两个功能，一个是传递this，另一个是传递参数（之后传参数会位于这些参数后面），它返回绑定后的函数。</p> <p>首先，我们要传递this，需要通过方法调用来完成，bind的this是原函数，我们要怎么返回绑定好的函数呢？🤔</p> <p>可以想到，我们先把函数绑定到那个环境上去，但这就是bind的功能啊。实际上，我们应该返回一个全新函数，而这个新函数的执行结果与原函数+thisArg一致。</p> <p>那么先不考虑传递参数，只考虑this的情况。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myBind</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">thisValue</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  thisValue<span class="token punctuation">.</span>_func <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> thisValue<span class="token punctuation">.</span><span class="token function">_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样我们就已经实现了bind最基本的功能——绑定this，但我们向thisValue添加了属性。其实我们只用保证结果正确，因此可以删除添加的属性，用临时变量替代。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myBind</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">thisValue</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">let</span> func <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token keyword">let</span> <span class="token function-variable function">getResult</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span>thisValue</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    thisValue<span class="token punctuation">.</span>_func <span class="token operator">=</span> func
    <span class="token keyword">let</span> result <span class="token operator">=</span> thisValue<span class="token punctuation">.</span><span class="token function">_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">delete</span> thisValue<span class="token punctuation">.</span>_func
    <span class="token keyword">return</span> result
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">getResult</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span>thisValue<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>细心的朋友不难看出，getResult和call、apply有着相似的功能，即返回绑定某个this值后的执行结果。也就是说，bind其实是基于call和apply实现的。但为了方便理解整个概念，我先介绍了bind。</p> <h4 id="call和apply"><a href="#call和apply" aria-hidden="true" class="header-anchor">#</a> call和apply</h4> <p>明白了基本原理之后，我们来研究如何传入参数。首先，我们应该知道所有参数都可以在aruguments对象中找到，我们先看一下它的结构：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">printArguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> arguments<span class="token punctuation">}</span>
<span class="token function">printArguments</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token comment">//[Arguments] { '0': 1, '1': 2, '2': 3 }</span>
</code></pre></div><p>Arguments是一个特殊的对象，它不是数组，但具有数组的许多特征，这里把它当作数组。</p> <p>先看<code>function.call(thisArg,arg1,arg2,...)</code>，我们需要把后面的参数传入函数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myCall</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">let</span> <span class="token punctuation">[</span>thisValue<span class="token punctuation">,</span><span class="token operator">...</span>parameters<span class="token punctuation">]</span> <span class="token operator">=</span> arguments
  thisValue<span class="token punctuation">.</span>_func <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> thisValue<span class="token punctuation">.</span><span class="token function">_func</span><span class="token punctuation">(</span><span class="token operator">...</span>parameters<span class="token punctuation">)</span>
  <span class="token keyword">delete</span> thisValue<span class="token punctuation">.</span>_func
  <span class="token keyword">return</span> result
<span class="token punctuation">}</span>
</code></pre></div><p>再看看<code>function.apply(thisArg,[argsArray])</code>，我们转换一下参数形式就行。需要注意我们的argsArray不能为空，如果为空，parameters为undefined，再使用扩展运算符就会报错<code>is not iterable</code>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myApply</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">let</span> <span class="token punctuation">[</span>thisValue<span class="token punctuation">,</span>parameters<span class="token punctuation">]</span> <span class="token operator">=</span> arguments
  thisValue<span class="token punctuation">.</span>_func <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> thisValue<span class="token punctuation">.</span><span class="token function">_func</span><span class="token punctuation">(</span><span class="token operator">...</span>parameters<span class="token punctuation">)</span>
  <span class="token keyword">delete</span> thisValue<span class="token punctuation">.</span>_func
  <span class="token keyword">return</span> result
<span class="token punctuation">}</span>
</code></pre></div><h4 id="可以完善的一些地方"><a href="#可以完善的一些地方" aria-hidden="true" class="header-anchor">#</a> 可以完善的一些地方</h4> <p>如果没有传this值，我们可以让默认值为window，如果没有传argsArray，让默认值为[]，这里拿apply作为例子。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myApply</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">let</span> <span class="token punctuation">[</span>thisValue<span class="token punctuation">,</span>parameters<span class="token punctuation">]</span> <span class="token operator">=</span> arguments
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>thisValue<span class="token punctuation">)</span>thisValue <span class="token operator">=</span> window
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>parameters<span class="token punctuation">)</span>parameters <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  thisValue<span class="token punctuation">.</span>_func <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> thisValue<span class="token punctuation">.</span><span class="token function">_func</span><span class="token punctuation">(</span><span class="token operator">...</span>parameters<span class="token punctuation">)</span>
  <span class="token keyword">delete</span> thisValue<span class="token punctuation">.</span>_func
  <span class="token keyword">return</span> result
<span class="token punctuation">}</span>
</code></pre></div><p>我们的bind也可以改造成使用apply的模式。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myBind</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">let</span> func <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token keyword">let</span> <span class="token punctuation">[</span>thisValue<span class="token punctuation">,</span><span class="token operator">...</span>parameters<span class="token punctuation">]</span> <span class="token operator">=</span> arguments
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> func<span class="token punctuation">.</span><span class="token function">myApply</span><span class="token punctuation">(</span>thisValue<span class="token punctuation">,</span>parameters<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在还可以继续考虑两个问题：如果不能使用…运算符怎么办？如果绑定的对象已经有了_func属性或者不能设置属性怎么办？</p> <p>先看如何替代…运算符。如果不能使用…运算符，我们就不能方便地向函数传递任意多个参数，可以使用eval()解析生成的字符串，也可以用<code>new Function([arg1[,arg2[,...argN]],]functionBody)</code>结合读取arguments数组读取任意多个参数，也是通过解析生成的字符串。</p> <p>使用不重复的属性。ES6提供了symbol()用于标志唯一的事物，它可以以作为对象的属性，我们仍以apply作为例子。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myApply</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">let</span> <span class="token punctuation">[</span>thisValue<span class="token punctuation">,</span>parameters<span class="token punctuation">]</span> <span class="token operator">=</span> arguments
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>thisValue<span class="token punctuation">)</span>thisValue <span class="token operator">=</span> window
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>parameters<span class="token punctuation">)</span>parameters <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">let</span> _func <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  thisValue<span class="token punctuation">[</span>_func<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> thisValue<span class="token punctuation">[</span>_func<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">...</span>parameters<span class="token punctuation">)</span>
  <span class="token keyword">delete</span> thisValue<span class="token punctuation">[</span>_func<span class="token punctuation">]</span>
  <span class="token keyword">return</span> result
<span class="token punctuation">}</span>
</code></pre></div><p>此外还可以用Math.random()生成一个不太可能重复的属性名。</p> <h2 id="作用域-scope"><a href="#作用域-scope" aria-hidden="true" class="header-anchor">#</a> 作用域 Scope</h2> <p>作用域即变量和函数的可访问范围和生命周期。</p> <h3 id="变量作用域"><a href="#变量作用域" aria-hidden="true" class="header-anchor">#</a> 变量作用域</h3> <p>可以分为全局作用域、函数内作用域（包括嵌套函数）、块级作用域。局部变量可以在局部覆盖同名全局变量。</p> <h3 id="作用域链-scope-chain"><a href="#作用域链-scope-chain" aria-hidden="true" class="header-anchor">#</a> 作用域链 Scope Chain</h3> <p>作用域链决定了函数能访问变量的范围，组织了访问变量的顺序，在解析标识符时一级一级地按顺序查找函数和变量。需要注意的是，JS根据函数定义的位置查找，而非执行的位置。</p> <h4 id="执行环境-执行上下文-execution-context"><a href="#执行环境-执行上下文-execution-context" aria-hidden="true" class="header-anchor">#</a> 执行环境/执行上下文 Execution Context</h4> <p>执行环境定义了变量与函数能访问的数据，包括全局、函数内、eval、块级作用域等。</p> <p>执行环境包括至少3个重要的属性：作用域链、变量对象和this（按创建顺序排序）。这里关注前两个。</p> <h4 id="变量对象-variable-object"><a href="#变量对象-variable-object" aria-hidden="true" class="header-anchor">#</a> 变量对象 Variable Object</h4> <p>每个执行环境都有与之关联的变量对象，它包括了环境中所有的变量和函数。全剧环境下的变量对象称为VO。</p> <p>所有的变量和函数即函数声明、变量声明、函数形参。不包括匿名函数。</p> <h4 id="活动对象-activation-object"><a href="#活动对象-activation-object" aria-hidden="true" class="header-anchor">#</a> 活动对象 Activation Object</h4> <p>当环境是函数时，活动对象就是变量对象。活动对象至少包含arguments对象（即函数参数）。有很多资料提到函数中不能直接访问VO，而以AO替代，不过反正这两个都是不能用JS代码打印出来的。</p> <p>Arguments对象至少包括callee（对当前函数的引用）、length（真正传递参数的个数）、properties-indexs（函数的参数值），注意Arguments并不包含this。</p> <h4 id="作用域链"><a href="#作用域链" aria-hidden="true" class="header-anchor">#</a> 作用域链</h4> <p>从外层到函数乃至嵌套函数内，多个执行环境形成了一个程序执行栈，同时也形成了一个指向多个环境的链表，即作用域链。</p> <p>作用域链包括VO与所有上级的作用域。</p> <h2 id="数组-array"><a href="#数组-array" aria-hidden="true" class="header-anchor">#</a> 数组 Array</h2> <h3 id="属性"><a href="#属性" aria-hidden="true" class="header-anchor">#</a> 属性</h3> <h4 id="length"><a href="#length" aria-hidden="true" class="header-anchor">#</a> length</h4> <p>数组长度/元素个数。</p> <h4 id="constructor"><a href="#constructor" aria-hidden="true" class="header-anchor">#</a> constructor</h4> <p>构造函数。</p> <h4 id="prototype"><a href="#prototype" aria-hidden="true" class="header-anchor">#</a> prototype</h4> <p>通过在原型上定义方法，让所有数组都可以使用自定义的方法。</p> <h3 id="变异方法与非变异方法-mutation-method-and-non-mutation-method"><a href="#变异方法与非变异方法-mutation-method-and-non-mutation-method" aria-hidden="true" class="header-anchor">#</a> 变异方法与非变异方法 mutation method and non-mutation method</h3> <p>有些方法改变原数组，称为变异方法；也有些方法返回一个新数组，称为非变异方法；剩下的那些方法不改变数组也不返回数组。下面用M和N标记变异与非变异方法。</p> <h3 id="map"><a href="#map" aria-hidden="true" class="header-anchor">#</a> map <span class="badge tip top" data-v-74aba598>N</span></h3> <p><code>Array.prototype.map(function(currentValue,index,arr),thisValue)</code></p> <p>map的作用是按回调函数的规则从原数组映射出一个新数组（作为返回值）。</p> <p>从函数原型可以看出，回调函数可以得到当前元素的值、索引、原数组，处理后的值应作为返回值，还能传入this对象。</p> <p>currentValue和index以及arr是只读的，但arr是对象，currentValue也可能是对象，此时可以修改属性或执行方法。</p> <h3 id="foreach-2"><a href="#foreach-2" aria-hidden="true" class="header-anchor">#</a> forEach</h3> <p><code>Array.prototype.forEach(function(currentValue, index, arr), thisValue)</code></p> <table><thead><tr><th>参数</th> <th>描述</th></tr></thead> <tbody><tr><td>function(currentValue, index, arr)</td> <td>必需。currentValue即当前元素（必需），index即索引值，arr即数组对象。</td></tr> <tr><td>thisValue</td> <td>传入的this值，默认undefined</td></tr></tbody></table> <p>无返回值，不能改变数组。如果数组成员是对象，当然可以更改其属性，因为数组只存了对象的指针。</p> <h3 id="reduce"><a href="#reduce" aria-hidden="true" class="header-anchor">#</a> reduce</h3> <p><code>Array.prototype.reduce(function(total, currentValue, index, arr), initialValue)</code></p> <p>迭代器，reduce从左到右遍历数组并接受一个函数作为累积器。这个函数接受上次迭代的返回值（total，而初始值可以用initialValue指定），并最终得到一个返回值作为reduce的返回值。</p> <p>使用reduce可以组织多个函数作为函数链，称为compose。</p> <h3 id="reduceright"><a href="#reduceright" aria-hidden="true" class="header-anchor">#</a> reduceRight</h3> <p>与reduce相似，但从右向左迭代。</p> <h3 id="filter"><a href="#filter" aria-hidden="true" class="header-anchor">#</a> filter <span class="badge tip top" data-v-74aba598>N</span></h3> <p><code>Array.prototype.filter(function(currentValue, index, arr), thisValue)</code></p> <p>过滤器，返回所有符合条件的项（回调函数中返回true）。不能改变数组。</p> <h3 id="push、pop"><a href="#push、pop" aria-hidden="true" class="header-anchor">#</a> push、pop <span class="badge warning top" data-v-74aba598>M</span></h3> <p><code>Array.prototype.push(arg1, arg2, ...)</code></p> <p><code>Array.prototype.pop()</code></p> <p>栈方法。进栈和出栈。进栈返回新数组长度，出栈返回出栈元素的值。</p> <h3 id="shift、unshift"><a href="#shift、unshift" aria-hidden="true" class="header-anchor">#</a> shift、unshift <span class="badge warning top" data-v-74aba598>M</span></h3> <p><code>Array.prototype.shift()</code></p> <p><code>Array.prototype.unshift(arg1, arg2 , ...)</code></p> <p>shift即出队列，删除数组第一项并将其作为返回值，unshift则是将item塞回队列（成为新数组的第0项、第1项等等）。push和shift方法结合使用则数组可以作为队列使用。</p> <h3 id="slice"><a href="#slice" aria-hidden="true" class="header-anchor">#</a> slice <span class="badge tip top" data-v-74aba598>N</span></h3> <p><code>Array.prototype.slice(start, end)</code></p> <p>切片的意思，即返回数组的一部分。start和end指定了开始和结束的数组下标，他们都接受负数值，-n代表从末尾向前数的第n个元素。</p> <h3 id="find"><a href="#find" aria-hidden="true" class="header-anchor">#</a> find <span class="badge tip top" data-v-74aba598>ES6</span></h3> <p><code>Array.prototype.find(function(currentValue, index, arr), thisValue)</code></p> <p>接受函数作为条件，返回第一个函数返回true的数组项。</p> <h3 id="findindex"><a href="#findindex" aria-hidden="true" class="header-anchor">#</a> findIndex <span class="badge tip top" data-v-74aba598>ES6</span></h3> <p>和find用法一致，返回第一个函数返回true的数组项的索引。如果找不到返回-1。</p> <h3 id="indexof"><a href="#indexof" aria-hidden="true" class="header-anchor">#</a> indexOf</h3> <p><code>Array.prototype.indexOf(item, start)</code></p> <p>indexOf接受一个值直接与数组项进行比较，返回第一次匹配的项的索引，如果找不到返回-1。start可以指定从哪一项开始搜索。</p> <h3 id="lastindexof"><a href="#lastindexof" aria-hidden="true" class="header-anchor">#</a> lastIndexOf</h3> <p><code>Array.prototype.lastIndexOf(item,start)</code></p> <p>与indexOf相似，但返回最后一个匹配项。</p> <h3 id="sort"><a href="#sort" aria-hidden="true" class="header-anchor">#</a> sort <span class="badge warning top" data-v-74aba598>M</span></h3> <p><code>Array.prototype.sort([compareFunction(firstEl,secondEl)])</code></p> <p>排序。修改原数组，返回对原数组的引用（即修改后的数组）。</p> <p>比较函数是可选的，接受比较的第一个元素和第二个元素，如果返回结果小于0，a将被排在b前面，如果大于0，b将被排在a前面，如果等于0，顺序不变（遗憾的是浏览器不一定遵守）。</p> <p>默认的sort将元素转为字符串并比较编码值大小。</p> <h3 id="reverse"><a href="#reverse" aria-hidden="true" class="header-anchor">#</a> reverse <span class="badge warning top" data-v-74aba598>M</span></h3> <p><code>Array.prototype.reverse()</code></p> <p>翻转数组。改变原数组，返回其引用。</p> <h3 id="splice"><a href="#splice" aria-hidden="true" class="header-anchor">#</a> splice <span class="badge warning top" data-v-74aba598>M</span></h3> <p><code>Array.prototype.slice(index[, howmany, item1, item2, ...])</code></p> <p>Splice的中文意为铰接、粘接，该方法可以自由地从数组添加、删除元素。</p> <p>第一个参数index用于确定<strong>位置</strong>，从哪里开始操作；第二个参数决定从下标为index的元素起，<strong>删除</strong>几个元素；后面的参数将会<strong>添加</strong>到数组中从index开始的位置上。</p> <h3 id="concat"><a href="#concat" aria-hidden="true" class="header-anchor">#</a> concat <span class="badge tip top" data-v-74aba598>N</span></h3> <p><code>Array.prototype.concat([arr1, arr2, ...])</code></p> <p>concat意为串联，即将两个或多个数组连接在一起并返回。参数为空时返回原数组拷贝，常用于复制数组。</p> <h3 id="join"><a href="#join" aria-hidden="true" class="header-anchor">#</a> join</h3> <p><code>Array.prototype.join([separator=&quot;,&quot;])</code></p> <p>join返回所有数组元素转换成的一个字符串，默认用半角逗号分隔，和toString表现一致，也可以自己指定分隔符。</p> <h3 id="fill"><a href="#fill" aria-hidden="true" class="header-anchor">#</a> fill <span class="badge warning top" data-v-74aba598>M</span> <span class="badge tip top" data-v-74aba598>ES6</span></h3> <p><code>Array.prototype.fill(value[, start=0[, end=array.length]])</code></p> <p>以固定值填充数组。start和end指定填充区间，array[end]不会被填充。</p> <h3 id="copywithin"><a href="#copywithin" aria-hidden="true" class="header-anchor">#</a> copyWithin <span class="badge warning top" data-v-74aba598>M</span></h3> <p><code>Array.prototype.copyWithin(targetIndex[, start[, end=array.length]])</code></p> <p>targetIndex确定了要复制到的位置，而start与end决定了被复制元素的范围。这种复制不是插入，而是覆盖原有元素，并且不改变数组长度。</p> <h3 id="includes"><a href="#includes" aria-hidden="true" class="header-anchor">#</a> includes <span class="badge tip top" data-v-74aba598>ES6</span></h3> <p><code>Array.prototype.includes(searchElement[, fromIndex])</code></p> <p>第一个参数传入值，第二个参数确定从哪开始搜索，-n代表倒数第n项。如果数组包括该值则返回true，否则返回false。</p> <h3 id="from"><a href="#from" aria-hidden="true" class="header-anchor">#</a> from <span class="badge tip top" data-v-74aba598>ES6</span></h3> <p><code>Array.prototype.from(object[, mapFunction[, thisValue]])</code></p> <p>object如果是拥有length属性或可迭代的对象，通过此方法能够返回一个数组。不符合要求的对象会导致from方法返回空数组。</p> <h3 id="every"><a href="#every" aria-hidden="true" class="header-anchor">#</a> every</h3> <div class="language- extra-class"><pre class="language-text"><code>Array.prototype.every(function(currentValue,index,arr),thisValue)
</code></pre></div><p>返回Boolean值，当且仅当所有元素传入回调函数的返回结果为true时every的结果为true。</p> <h3 id="some"><a href="#some" aria-hidden="true" class="header-anchor">#</a> some</h3> <p>和every用法一致，有一个元素传入回调的结果为true即返回true并不再检验之后的元素。</p> <h3 id="entries"><a href="#entries" aria-hidden="true" class="header-anchor">#</a> entries <span class="badge tip top" data-v-74aba598>ES6</span></h3> <div class="language- extra-class"><pre class="language-text"><code>Array.prototype.entries()
</code></pre></div><p>从数组返回一个可迭代对象(Array Iterator)。如果不明白可以先了解function generator。</p> <h3 id="keys"><a href="#keys" aria-hidden="true" class="header-anchor">#</a> keys <span class="badge tip top" data-v-74aba598>ES6</span></h3> <p><code>Array.prototype.keys()</code></p> <p>创建key的可迭代对象，而数组的key是0、1、2、3...</p> <h3 id="isarray"><a href="#isarray" aria-hidden="true" class="header-anchor">#</a> isArray</h3> <p><code>Array.prototype.isArray(obj)</code></p> <p>顾名思义，判断是否数组，返回Boolean值。</p> <h3 id="tostring"><a href="#tostring" aria-hidden="true" class="header-anchor">#</a> toString</h3> <p>其实和join类似，返回字符串，不过不带参数，只能以逗号分隔。</p> <h3 id="valueof"><a href="#valueof" aria-hidden="true" class="header-anchor">#</a> valueOf</h3> <p>数组对象的默认方法，返回数组原始值。不必手动调用。</p> <h2 id="对象"><a href="#对象" aria-hidden="true" class="header-anchor">#</a> 对象</h2> <h3 id="可枚举属性-enumerable-properties"><a href="#可枚举属性-enumerable-properties" aria-hidden="true" class="header-anchor">#</a> 可枚举属性 Enumerable Properties</h3> <p>Object.keys()、for...in、JSON.stringily()都只处理可枚举属性，可以用Object.propertyIsEnumerable()方法判断属性是否可枚举。</p> <p>定义一个不可枚举属性：</p> <div class="language- extra-class"><pre class="language-text"><code>let obj = {}
obj.defineProperty(obj,&quot;attr&quot;,{
	value:&quot;bread&quot;,
	enumerable:false
})
</code></pre></div><p>待填坑</p> <p>如果属性存在于原型</p> <h3 id="对象拷贝"><a href="#对象拷贝" aria-hidden="true" class="header-anchor">#</a> 对象拷贝</h3> <p>除了接下来介绍的Object.assign()，还可以用JSON.parse(JSON.stringify())深拷贝对象，对于数组可以用concat()。</p> <h3 id="object-assign"><a href="#object-assign" aria-hidden="true" class="header-anchor">#</a> Object.assign()</h3> <p><code>Object.assign(target, ...source)</code></p> <p>（浅）拷贝数组，将所有可枚举属性从一个或多个源对象复制到目标对象，并将其作为返回值。需要注意它调用源对象的Setter和目标对象的Getter，如果合并源包括Getter或目标包括Setter，那么应该使用Object.getOwnPropertyDescriptor()与Object.defineProperty()准确复制属性定义。</p> <h2 id="原型-prototype"><a href="#原型-prototype" aria-hidden="true" class="header-anchor">#</a> 原型 Prototype</h2> <p>JavaScript中的继承。</p> <h2 id="string方法"><a href="#string方法" aria-hidden="true" class="header-anchor">#</a> String方法</h2> <p>字符串方法均返回新值，不改变原字符串。</p> <h3 id="substring"><a href="#substring" aria-hidden="true" class="header-anchor">#</a> substring</h3> <p><code>String.prototype.substring(from[, to=array.length])</code></p> <p>给定两个下标，截取部分字符串作为返回值，arr[to]不会被截取。</p> <h3 id="substr"><a href="#substr" aria-hidden="true" class="header-anchor">#</a> substr</h3> <p><code>String.prototype.substr(start[, length=array.length-start])</code></p> <p>截取从arr[start]开始的length个字符作为返回值，不指定length则截取到结尾。</p> <h3 id="trim"><a href="#trim" aria-hidden="true" class="header-anchor">#</a> trim</h3> <p>去除字符串两边的空格作为返回值。</p> <h3 id="split"><a href="#split" aria-hidden="true" class="header-anchor">#</a> split</h3> <p><code>String.prototype.split([separator[, limit]])</code></p> <p>将字符串按分隔符拆成数组，separator可以是字符串或RegExp，默认不会拆分，传入&quot;&quot;空字符串可拆分每一个字符，limit限制返回子字符串的最大数量（达到limit个子字符串后split即返回）。</p> <h3 id="slice-2"><a href="#slice-2" aria-hidden="true" class="header-anchor">#</a> slice</h3> <p><code>String.prototype.slice(start[, end=array.length])</code></p> <p>截取字符串片段，不包括arr[end]，end可以为负（-n代表倒数第n个）。</p> <h3 id="replace"><a href="#replace" aria-hidden="true" class="header-anchor">#</a> replace</h3> <p><code>String.prototype.replace(searchValue, newValue)</code></p> <p>接受字符串或RegExp进行匹配和替换。如果是字符串只能替换第一次匹配的子字符串，正则表达式可以替换所有的项（<code>/str/g</code>）。</p> <h3 id="match"><a href="#match" aria-hidden="true" class="header-anchor">#</a> match</h3> <p><code>String.prototype.match(RegExp)</code></p> <p>接受一个正则表达式，返回结果数组或null。</p> <h3 id="search"><a href="#search" aria-hidden="true" class="header-anchor">#</a> search</h3> <p><code>String.prototype.search(searchValue)</code></p> <p>接受字符串或正则表达式，返回第一次匹配的子字符串起始位置的下标，找不到返回-1。</p> <h3 id="indexof-2"><a href="#indexof-2" aria-hidden="true" class="header-anchor">#</a> indexOf</h3> <p><code>String.prototype.indexOf(searchValue[, start])</code></p> <p>与search相似，但只接受字符串，可以给一个开始搜索的位置。注意它不会来回找，如果在start到end区间都没有匹配项就返回-1。</p> <h3 id="lastindexof-2"><a href="#lastindexof-2" aria-hidden="true" class="header-anchor">#</a> lastIndexOf</h3> <p><code>String.prototype.lastIndexOf(searchValue[, start])</code></p> <p>与indexOf的区别在于，该方法从后往前找，能找到最后一次出现的位置。</p> <h3 id="includes-2"><a href="#includes-2" aria-hidden="true" class="header-anchor">#</a> includes <span class="badge tip top" data-v-74aba598>ES6</span></h3> <p><code>String.prototype.includes(searchValue[, start])</code></p> <p>与indexOf类似，但不返回子字符串位置，只返回Boolean值。</p> <h3 id="concat-2"><a href="#concat-2" aria-hidden="true" class="header-anchor">#</a> concat</h3> <p><code>String.prototype.concat([str1[, str2[, ...]]])</code></p> <p>连接多个字符串并作为结果返回。</p> <h3 id="tolowercase"><a href="#tolowercase" aria-hidden="true" class="header-anchor">#</a> toLowerCase</h3> <p>将大写转换成小写字母并返回。</p> <h3 id="touppercase"><a href="#touppercase" aria-hidden="true" class="header-anchor">#</a> toUpperCase</h3> <p>将小写转换成大写字母并返回。</p> <h3 id="repeat"><a href="#repeat" aria-hidden="true" class="header-anchor">#</a> repeat <span class="badge tip top" data-v-74aba598>ES6</span></h3> <p><code>String.prototype.repeat(count=0)</code></p> <p>将字符串复制指定次数合并成一个字符串返回，默认count=0即返回空字符串。</p> <h3 id="startswith"><a href="#startswith" aria-hidden="true" class="header-anchor">#</a> startsWith <span class="badge tip top" data-v-74aba598>ES6</span></h3> <p><code>String.prototype.startsWith(value[, start=0])</code></p> <p>用于判断字符串是否以value开头。不过start可以自定义，也就是判断字符串start处是否有字符串value。返回结果为Boolean值。</p> <h3 id="charat"><a href="#charat" aria-hidden="true" class="header-anchor">#</a> charAt</h3> <p><code>String.prototype.charAt(index=0)</code></p> <p>接受index并返回str[index]。</p> <h3 id="charcodeat"><a href="#charcodeat" aria-hidden="true" class="header-anchor">#</a> charCodeAt</h3> <p><code>String.prototype.charCodeAt(index=0)</code></p> <p>接受index并返回str[index]的Unicode编码。</p> <h3 id="fromcharcode"><a href="#fromcharcode" aria-hidden="true" class="header-anchor">#</a> fromCharCode</h3> <p><code>String.fromCharCode([code1[, code2[, ...]]])</code></p> <p>接受一个或多个字符编码，返回创建的字符串。</p> <h3 id="html包装方法"><a href="#html包装方法" aria-hidden="true" class="header-anchor">#</a> HTML包装方法</h3> <p>包括anchor、big、blink、bold、fixed、fontcolor、fontsize、italics、link、small、strike、sub、sup。这些方法从字符串返回一个HTML标签用于网页中展示。</p> <h2 id="错误处理"><a href="#错误处理" aria-hidden="true" class="header-anchor">#</a> 错误处理</h2> <h3 id="try-catch"><a href="#try-catch" aria-hidden="true" class="header-anchor">#</a> try...catch</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
  <span class="token comment">//insert code here</span>
  a<span class="token punctuation">.</span>b<span class="token operator">=</span>c
<span class="token punctuation">}</span>
<span class="token keyword">catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">&quot;Error catched: &quot;</span><span class="token operator">+</span>err<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="throw-2"><a href="#throw-2" aria-hidden="true" class="header-anchor">#</a> throw</h3> <p>抛出自定义错误。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
  <span class="token keyword">throw</span> <span class="token string">'Number is too big'</span>
<span class="token punctuation">}</span>
<span class="token keyword">catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="finally"><a href="#finally" aria-hidden="true" class="header-anchor">#</a> finally</h3> <p>无论是否发生错误都会执行的语句。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
<span class="token keyword">catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
<span class="token keyword">finally</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="error对象"><a href="#error对象" aria-hidden="true" class="header-anchor">#</a> Error对象</h3> <p>如果是内置错误（非throw抛出），抛出的是一个Error对象。包括name和message属性。</p> <p>错误名name通常包括ReferenceError（引用尚未声明的变量）、SyntaxError（语法错误）、TypeError（类型错误，如xxx is not a function）、URIError（由URI函数抛出）、rangeError（由Number的方法抛出）。</p> <h2 id="参考"><a href="#参考" aria-hidden="true" class="header-anchor">#</a> 参考</h2> <h3 id="模板字符串"><a href="#模板字符串" aria-hidden="true" class="header-anchor">#</a> 模板字符串</h3> <p>`我买了${a}箱苹果``</p> <h3 id="变量作用域-2"><a href="#变量作用域-2" aria-hidden="true" class="header-anchor">#</a> 变量作用域</h3> <p>JS中变量的作用域可以是全局，也可以是局部（函数参数和局部变量），同名局部变量会</p> <h4 id="函数作用域"><a href="#函数作用域" aria-hidden="true" class="header-anchor">#</a> 函数作用域</h4> <p>JS的函数作用域是指在函数内声明的变量始终可见（变量提升）。</p> <h5 id="作用域链-2"><a href="#作用域链-2" aria-hidden="true" class="header-anchor">#</a> 作用域链</h5> <p>JS查找上级作用域时，根据定义的位置查找，与执行环境无关。</p> <h2 id="参考目录"><a href="#参考目录" aria-hidden="true" class="header-anchor">#</a> 参考目录</h2> <p>this</p> <p>https://www.cnblogs.com/xiaohuochai/p/5735901.html</p> <p>JavaScript</p> <p>https://www.liaoxuefeng.com/wiki/1022910821149312</p> <p>ECMA Script 6</p> <p>http://es6.ruanyifeng.com/</p> <p>Execution Context</p> <p>https://juejin.im/entry/58edde2761ff4b00581b93ff</p> <p>Symbol</p> <p>https://www.cnblogs.com/diligenceday/p/5462733.html</p> <p>MDN</p> <p>runoob</p></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/NTT-Frontend-Navigation.github.io/assets/js/app.f231f552.js" defer></script><script src="/NTT-Frontend-Navigation.github.io/assets/js/6.899d55bc.js" defer></script><script src="/NTT-Frontend-Navigation.github.io/assets/js/2.d922ff4b.js" defer></script>
  </body>
</html>
