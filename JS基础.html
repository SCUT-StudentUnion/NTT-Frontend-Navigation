<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JavaScript基础 | NTT Front-end Navigation</title>
    <meta name="description" content="网络队前端技术导航">
    
    
    <link rel="preload" href="/NTT-Frontend-Navigation.github.io/assets/css/0.styles.197cc9d4.css" as="style"><link rel="preload" href="/NTT-Frontend-Navigation.github.io/assets/js/app.829b5ce9.js" as="script"><link rel="preload" href="/NTT-Frontend-Navigation.github.io/assets/js/3.8cef8892.js" as="script"><link rel="prefetch" href="/NTT-Frontend-Navigation.github.io/assets/js/2.d922ff4b.js"><link rel="prefetch" href="/NTT-Frontend-Navigation.github.io/assets/js/4.dcfdfa44.js"><link rel="prefetch" href="/NTT-Frontend-Navigation.github.io/assets/js/5.e2095af7.js"><link rel="prefetch" href="/NTT-Frontend-Navigation.github.io/assets/js/6.7129398d.js"><link rel="prefetch" href="/NTT-Frontend-Navigation.github.io/assets/js/7.b62d252f.js">
    <link rel="stylesheet" href="/NTT-Frontend-Navigation.github.io/assets/css/0.styles.197cc9d4.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/NTT-Frontend-Navigation.github.io/" class="home-link router-link-active"><!----> <span class="site-name">NTT Front-end Navigation</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/NTT-Frontend-Navigation.github.io/" class="nav-link">主页</a></div><div class="nav-item"><a href="/NTT-Frontend-Navigation.github.io/JS基础.html" class="nav-link">JS基础</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/NTT-Frontend-Navigation.github.io/" class="nav-link">主页</a></div><div class="nav-item"><a href="/NTT-Frontend-Navigation.github.io/JS基础.html" class="nav-link">JS基础</a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>JavaScript基础</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#数据类型" class="sidebar-link">数据类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#number" class="sidebar-link">Number</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#string" class="sidebar-link">String</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#boolean" class="sidebar-link">Boolean</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#null-undefined" class="sidebar-link">null&amp;undefined</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#object" class="sidebar-link">Object</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#array" class="sidebar-link">Array</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#date" class="sidebar-link">Date</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#map-set" class="sidebar-link">Map&amp;Set</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#function" class="sidebar-link">Function</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#symbol" class="sidebar-link">Symbol</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#typeof-instanceof" class="sidebar-link">typeof&amp;instanceof</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#动态类型-类型转换" class="sidebar-link">动态类型&amp;类型转换</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#基本类型-基本类型包装" class="sidebar-link">基本类型&amp;基本类型包装</a></li></ul></li><li><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#变量声明-declaration" class="sidebar-link">变量声明 Declaration</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#var" class="sidebar-link">var</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#let-const" class="sidebar-link">let&amp;const</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#命名规范" class="sidebar-link">命名规范</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#函数声明" class="sidebar-link">函数声明</a></li></ul></li><li><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#运算符" class="sidebar-link">运算符</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#_1-与" class="sidebar-link">1 ==与===</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#_2" class="sidebar-link">2 &amp;&amp;</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#_3" class="sidebar-link">3 ||</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#_4" class="sidebar-link">4 ...</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#_5" class="sidebar-link">5 + - * /</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#_6" class="sidebar-link">6 []</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#_7" class="sidebar-link">7 .</a></li></ul></li><li><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#关键字" class="sidebar-link">关键字</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#new" class="sidebar-link">new</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#delete" class="sidebar-link">delete</a></li></ul></li><li><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#循环体" class="sidebar-link">循环体</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#array-foreach" class="sidebar-link">Array.forEach</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#for…in" class="sidebar-link">for…in</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#for…of" class="sidebar-link">for…of</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#iterable接口" class="sidebar-link">iterable接口</a></li></ul></li><li><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#内置对象" class="sidebar-link">内置对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#math" class="sidebar-link">Math</a></li></ul></li><li><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#函数简介" class="sidebar-link">函数简介</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#this" class="sidebar-link">this</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#绑定this" class="sidebar-link">绑定this</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#this与函数" class="sidebar-link">this与函数</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#实现bind" class="sidebar-link">实现bind</a></li></ul></li><li><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#作用域-scope" class="sidebar-link">作用域 Scope</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#变量作用域" class="sidebar-link">变量作用域</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#作用域链-scope-chain" class="sidebar-link">作用域链 Scope Chain</a></li></ul></li><li><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#数组方法" class="sidebar-link">数组方法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#map" class="sidebar-link">map</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#every" class="sidebar-link">every</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#some" class="sidebar-link">some</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#foreach" class="sidebar-link">forEach</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#reduce" class="sidebar-link">reduce</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#push、pop" class="sidebar-link">push、pop</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#shift、unshift" class="sidebar-link">shift、unshift</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#slice" class="sidebar-link">slice</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#indexof" class="sidebar-link">indexOf</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#sort" class="sidebar-link">sort</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#reverse" class="sidebar-link">reverse</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#splice" class="sidebar-link">splice</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#concat" class="sidebar-link">concat</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#join" class="sidebar-link">join</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#tostring" class="sidebar-link">toString</a></li></ul></li><li><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#对象方法" class="sidebar-link">对象方法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#object-assign" class="sidebar-link">Object.assign()</a></li></ul></li><li><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#string方法" class="sidebar-link">String方法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#substring" class="sidebar-link">substring</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#split" class="sidebar-link">split</a></li></ul></li><li><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#参考" class="sidebar-link">参考</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#模板字符串" class="sidebar-link">模板字符串</a></li><li class="sidebar-sub-header"><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#变量作用域-2" class="sidebar-link">变量作用域</a></li></ul></li><li><a href="/NTT-Frontend-Navigation.github.io/JS%E5%9F%BA%E7%A1%80.html#参考目录" class="sidebar-link">参考目录</a><ul class="sidebar-sub-headers"></ul></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="javascript基础"><a href="#javascript基础" aria-hidden="true" class="header-anchor">#</a> JavaScript基础</h1> <p>用看得懂的话写de教程。</p> <h2 id="数据类型"><a href="#数据类型" aria-hidden="true" class="header-anchor">#</a> 数据类型</h2> <p>JavaScript的原始数据类型包括Number、String、Boolean、Null、Undefined、Symbol（ES6新增），此外有Object类型。</p> <h3 id="number"><a href="#number" aria-hidden="true" class="header-anchor">#</a> Number</h3> <p>不区分整数和浮点，注意浮点计算结果是不精确的（由于浮点数的计算方式），对浮点数不建议直接用等号判断两值相等，应当看他们的差是否小于某个值（如0.001）。Infinity（超过Number最大值）、NaN（Not a Number）也是合法的Number。</p> <div class="tip custom-block"><p class="custom-block-title">关于NaN</p> <p>NaN是特殊的Number，它也不等于自己，只能通过isNaN()判断。</p></div> <h3 id="string"><a href="#string" aria-hidden="true" class="header-anchor">#</a> String</h3> <p>单引号‘’或双引号&quot;&quot;包裹的字符串。</p> <h3 id="boolean"><a href="#boolean" aria-hidden="true" class="header-anchor">#</a> Boolean</h3> <p>Boolean包括'true'、'false'两种取值。比较运算符、&amp;&amp;、||与!都会产生布尔值。</p> <div class="tip custom-block"><p class="custom-block-title">转换结果为false的取值</p> <p>NaN、null、undefined、0转Boolean的结果都为false。</p></div> <h3 id="null-undefined"><a href="#null-undefined" aria-hidden="true" class="header-anchor">#</a> null&amp;undefined</h3> <p>null表示空值，undefined表示未赋值，undefined可以用于判断函数参数是否传递。他们是两种数据类型。</p> <div class="tip custom-block"><p class="custom-block-title">null和undefined的区别</p> <ol><li><p>null是保留字，而undefined不是。</p></li> <li><p>如果访问不存在的变量，会报错&quot;var is not defined&quot;；访问已声明但未赋值的变量才会得到undefined。</p></li> <li><p>typeof null的结果是object，但null也是一种基本类型而非object，这个混淆是由于typeof以内存低位判断数据类型，object和null的低3位都是0。</p></li></ol></div> <h3 id="object"><a href="#object" aria-hidden="true" class="header-anchor">#</a> Object</h3> <p>键-值对的无序集合。键（key）只能是字符串类型，值（value）可以是任意类型。'.'可以用于表示键路径，比如obj.key或obj.obj.a。</p> <p>Object是引用类型，存储的是针，而其他基本类型存储值。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>key<span class="token punctuation">:</span><span class="token string">'value'</span><span class="token punctuation">,</span>
           obj<span class="token punctuation">:</span><span class="token punctuation">{</span>
             a<span class="token punctuation">:</span><span class="token string">'a'</span>
           <span class="token punctuation">}</span><span class="token punctuation">}</span>
</code></pre></div><h3 id="array"><a href="#array" aria-hidden="true" class="header-anchor">#</a> Array</h3> <p>用[]或new Array()创建，数组可以包含任意类型元素并且提供了相当多的方法。Array属于Object类型。</p> <h3 id="date"><a href="#date" aria-hidden="true" class="header-anchor">#</a> Date</h3> <p>Date类型提供了丰富的与时间、日期相关的方法，Date()返回当前日期的字符串。Date也属于Object类型。</p> <h3 id="map-set"><a href="#map-set" aria-hidden="true" class="header-anchor">#</a> Map&amp;Set</h3> <p>ES6新增的数据结构。</p> <p>Map是一组key-value对结构，key不能重复，否则只保留最新的值。与对象只支持string与symbol相比，Map 的key支持任意类型。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> students <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'Lucy'</span><span class="token punctuation">,</span><span class="token number">90</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'Peter'</span><span class="token punctuation">,</span><span class="token number">80</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'Bill'</span><span class="token punctuation">,</span><span class="token number">85</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
students<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'Lucy'</span><span class="token punctuation">)</span><span class="token comment">//90</span>
students<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token string">'Peter'</span><span class="token punctuation">)</span><span class="token comment">//true</span>
students<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">'Peter'</span><span class="token punctuation">)</span><span class="token comment">//true</span>
students<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'Peter'</span><span class="token punctuation">)</span><span class="token comment">//undefined</span>
students<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">'Bill'</span><span class="token punctuation">,</span><span class="token number">90</span><span class="token punctuation">)</span><span class="token comment">//Map { 'Lucy' =&gt; 90, 'Bill' =&gt; 90 }</span>
students<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'Bill'</span><span class="token punctuation">)</span><span class="token comment">//90</span>
</code></pre></div><p>Set类似集合，由一组不重复的key组成，否则只保留一个。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> foods <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'Chicken'</span><span class="token punctuation">,</span><span class="token string">'Noodles'</span><span class="token punctuation">,</span><span class="token string">'Rice'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
foods<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'fish'</span><span class="token punctuation">)</span><span class="token comment">//Set { 'Chicken', 'Noodles', 'Rice', 'fish' }</span>
foods<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">'Noodles'</span><span class="token punctuation">)</span><span class="token comment">//true</span>
foods<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token string">'Rice'</span><span class="token punctuation">)</span><span class="token comment">//true</span>
</code></pre></div><h3 id="function"><a href="#function" aria-hidden="true" class="header-anchor">#</a> Function</h3> <p>有趣的是，函数是Object的实例，而Object也是函数的实例。</p> <h3 id="symbol"><a href="#symbol" aria-hidden="true" class="header-anchor">#</a> Symbol</h3> <p>用于产生唯一标识，除了自己等于自己，两个完全相同的symbol不相等，常用于对象属性、声明唯一常量、定义私有属性。也可以用Symbol.for()创建symbol，如果参数一致，创建的symbol相等。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span>
s <span class="token operator">==</span> s1<span class="token comment">//false</span>
s <span class="token operator">===</span> s<span class="token comment">//true</span>
<span class="token keyword">let</span> s2 <span class="token operator">=</span> Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> s3 <span class="token operator">=</span> Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span>
s2 <span class="token operator">==</span> s3<span class="token comment">//true</span>
</code></pre></div><p>你可以通过以下方式获取Symbol的description（无需记忆）。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> s2 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">&quot;love&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">[</span>s2<span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token string">&quot;and peace&quot;</span><span class="token punctuation">}</span>
obj<span class="token comment">//{ [Symbol(love)]: 'and peace' }</span>
Object<span class="token punctuation">.</span><span class="token function">getOwnPropertySymbols</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token comment">//[ Symbol(love) ]</span>
Reflect<span class="token punctuation">.</span><span class="token function">ownKeys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token comment">//[ Symbol(love) ]</span>
</code></pre></div><p>Symbol定义了对象的许多实用方法，包括[Symbol.Iterator]、[Symbol.match]、[Symbol.replace]、[Symbol.split]、[Symbol.toPrimitive]、[Symbol.toStringTag]等。toStringTag方法甚至能改变对象的toString方法。</p> <h3 id="typeof-instanceof"><a href="#typeof-instanceof" aria-hidden="true" class="header-anchor">#</a> typeof&amp;instanceof</h3> <p>typeof返回字符串有以下结果“number”、“string”、“boolean”、“object”、“function”、“undefined”、“symbol”，null打印为“object”。而instanceof用于判断检测对象的类型，包括&quot;Array&quot;、&quot;Function&quot;、&quot;Object&quot;及自定义类/构造函数等。</p> <p>此外Object.prototype.toString.call()可以准确打印出Null的类型。也可以通过访问&quot;.constructor&quot;获取构造函数判断类型。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">typeof</span> a<span class="token comment">//'object'</span>
a <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token comment">//true</span>

<span class="token keyword">class</span> <span class="token class-name">y</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">let</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
t <span class="token keyword">instanceof</span> <span class="token class-name">y</span><span class="token comment">//true</span>
</code></pre></div><h3 id="动态类型-类型转换"><a href="#动态类型-类型转换" aria-hidden="true" class="header-anchor">#</a> 动态类型&amp;类型转换</h3> <p>作为动态语言，JS允许同一个变量在不同时间用作不同类型。</p> <h4 id="使用javascript函数转换"><a href="#使用javascript函数转换" aria-hidden="true" class="header-anchor">#</a> 使用JavaScript函数转换</h4> <p>例如全局方法（构造函数）String()、Number()、Date()以及变量的toString()方法等。不同类型还会有独有的方法比如Date变量的getDate()、getDay()，Number变量的toPrecision()等。</p> <h4 id="使用javascript自动转换"><a href="#使用javascript自动转换" aria-hidden="true" class="header-anchor">#</a> 使用JavaScript自动转换</h4> <p>变量类型会根据需要发生类型转换，例如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">5</span> <span class="token operator">+</span> <span class="token keyword">null</span> <span class="token comment">//5 因为null=0</span>
<span class="token number">5</span> <span class="token operator">+</span> <span class="token keyword">undefined</span> <span class="token comment">//NaN 因为undefined转为数字是NaN</span>
<span class="token string">&quot;0&quot;</span><span class="token operator">+</span> <span class="token keyword">null</span> <span class="token comment">//&quot;0null&quot; 因为null=&quot;null&quot;</span>
<span class="token string">&quot;5&quot;</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token comment">//&quot;51&quot; 因为1=&quot;1&quot;</span>
<span class="token number">1</span> <span class="token operator">+</span> <span class="token string">&quot;5&quot;</span> <span class="token comment">//&quot;51&quot; 因为1=&quot;1&quot;</span>
<span class="token string">&quot;5&quot;</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token comment">//4 因为&quot;5&quot;=5</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token comment">//&quot;1,21&quot; 数组先转字符串，再加&quot;1&quot;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">&quot;str&quot;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">//这里的代码将会执行，因为“str”可以转为true</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以观察到含字符串类型会转为字符串，没有或不能转字符串的话转数字（除加号以外，结果转数字）。</p> <p>自动转换有一些基础规则，比如Boolean值的转换：true等于1，false等于0，空字符串、空数组和null等于0，非纯数字字符串转为NaN等。</p> <p>有趣的是，&quot;0&quot;可以转为Boolean的“true”，但“0”转为数字0之后再转Boolean就会变成“false”。空数组也可以转“true”，转数字之后也为0。</p> <h3 id="基本类型-基本类型包装"><a href="#基本类型-基本类型包装" aria-hidden="true" class="header-anchor">#</a> 基本类型&amp;基本类型包装</h3> <p>除了Object类型存储的是引用，所有类型都是基本类型（存储值），但除了null和undefined，他们都像对象一样拥有自己的方法。这不是因为基本类型具有方法，而是在调用基本类型的方法时，JS引擎自动包装了基本类型，调用结束后销毁对象。</p> <p>因此，向基本类型添加属性是无效的，因为添加完成后临时对象即被销毁，但可以向其原型添加属性和方法。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">'str'</span>
str<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">/*
相当于做了这些事
var _str = new String(str)
str = _str.toUpperCase()
*/</span>
</code></pre></div><h2 id="变量声明-declaration"><a href="#变量声明-declaration" aria-hidden="true" class="header-anchor">#</a> 变量声明 Declaration</h2> <h3 id="var"><a href="#var" aria-hidden="true" class="header-anchor">#</a> var</h3> <p>变量用var声明，不用var则作为全局变量。var声明的变量处于全局作用域或函数作用域。</p> <h4 id="变量提升-hoisting"><a href="#变量提升-hoisting" aria-hidden="true" class="header-anchor">#</a> 变量提升 Hoisting</h4> <p>用var声明的变量，可以在声明语句之前使用，但不会初始化（赋值）。因此访问他们虽然不会报错，但会得到undefined。</p> <h3 id="let-const"><a href="#let-const" aria-hidden="true" class="header-anchor">#</a> let&amp;const</h3> <p>ES6中新增了let与const关键字，分别代表块级作用域中的变量与常量，同时不允许重复声明，没有变量提升。</p> <h4 id="块级作用域"><a href="#块级作用域" aria-hidden="true" class="header-anchor">#</a> 块级作用域</h4> <p>由{}包裹的代码块。在for循环中，()与{}是父子块级作用域，也就是说{}用let或const声明的变量不会影响for循环计数。</p> <p>块级作用域没有变量提升，可以防止在函数内使用上级变量时，后面声明的变量意外覆盖上级变量。</p> <p>使用var声明变量：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> h<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span>
<span class="token keyword">var</span> h<span class="token punctuation">;</span><span class="token comment">//覆盖了上级变量</span>
<span class="token punctuation">}</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//undefined</span>
</code></pre></div><p>使用let声明变量：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> h<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token comment">//暂时性死区</span>
<span class="token keyword">let</span> h<span class="token punctuation">;</span><span class="token comment">//与当前作用域绑定，声明之前不可读取</span>
<span class="token punctuation">}</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//ReferenceError: Cannot access 'h' before initialization</span>
</code></pre></div><p>同时块间的隔离有助于减少冲突和出错。此前，JS只能用函数作用域来隔离变量，常用的方式就是匿名立即执行函数（匿名IIFE）。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> hours<span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">//等同于</span>
<span class="token punctuation">{</span><span class="token keyword">let</span> hours<span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">}</span>
</code></pre></div><div class="tip custom-block"><p class="custom-block-title">暂时性死区 temporal dead zone</p> <p>let和const声明的变量会与代码块绑定，在声明前不能使用同名的上级环境变量，否则会引发报错。</p></div> <h3 id="命名规范"><a href="#命名规范" aria-hidden="true" class="header-anchor">#</a> 命名规范</h3> <p>变量名由26字母的大小写、数字、“$“和”_“组成，不能用数字开头。甚至支持中文，但不建议使用，避免引发麻烦。</p> <h3 id="函数声明"><a href="#函数声明" aria-hidden="true" class="header-anchor">#</a> 函数声明</h3> <p>推荐使用函数表达式<code>let func=()=&gt;{}</code>为变量赋值，因此函数声明也遵循以上规则。如果用<code>function func(){}</code>直接声明函数，ES5中函数声明能完整地提升，ES6虽然规定了行为类似let，但实际可能会先赋值为undefined，不同环境可能有不同的处理。</p> <h2 id="运算符"><a href="#运算符" aria-hidden="true" class="header-anchor">#</a> 运算符</h2> <h3 id="_1-与"><a href="#_1-与" aria-hidden="true" class="header-anchor">#</a> 1 ==与===</h3> <p>==表示在类型转换后相等，===表示类型和值都一样。除非需要用到==的特性，否则建议用===比较。</p> <div class="tip custom-block"><p class="custom-block-title">比较对象</p> <p>对象的比较与原始值不同，比较的是引用，因此两个完全相同的数组不相等，除非他们是对同一处的引用。</p></div> <h3 id="_2"><a href="#_2" aria-hidden="true" class="header-anchor">#</a> 2 &amp;&amp;</h3> <p>‘与’运算符，如果左边表达式的值是false或可以转为false则返回左边表达式的值，否则返回右边表达式的值。</p> <p>Boolean角度：&amp;&amp;只有当两边都为true，结果才为true，如果左边结果为false，右边不会判断。</p> <h3 id="_3"><a href="#_3" aria-hidden="true" class="header-anchor">#</a> 3 ||</h3> <p>‘或’运算符，如果左边表达式的值是true或可以转为true则返回左边表达式的值，否则返回右边表达式的值。</p> <p>Boolean角度：||只有当两边都为false，结果才为false，如果左边结果为true，右边不会判断。</p> <h3 id="_4"><a href="#_4" aria-hidden="true" class="header-anchor">#</a> 4 ...</h3> <p>ES6中的扩展运算符，用在数组或对象前表示取出所有项或属性。</p> <h4 id="用于对象"><a href="#用于对象" aria-hidden="true" class="header-anchor">#</a> 用于对象</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> obj<span class="token operator">=</span><span class="token punctuation">{</span>a<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span>b<span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">}</span>
<span class="token keyword">let</span> newObj<span class="token operator">=</span><span class="token punctuation">{</span><span class="token operator">...</span>obj<span class="token punctuation">,</span>c<span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token comment">//{ a: 1, b: 2, c: 3 }</span>
</code></pre></div><h4 id="用于数组"><a href="#用于数组" aria-hidden="true" class="header-anchor">#</a> 用于数组</h4> <h5 id="赋值"><a href="#赋值" aria-hidden="true" class="header-anchor">#</a> 赋值</h5> <p>生成数组的拷贝。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> arr<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> newArr<span class="token operator">=</span><span class="token punctuation">[</span><span class="token operator">...</span>arr<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token comment">//[ 0, 1, 2, 3, 4 ]</span>
</code></pre></div><h5 id="解构赋值"><a href="#解构赋值" aria-hidden="true" class="header-anchor">#</a> 解构赋值</h5> <p>结合解构赋值，它还提供了生成数组的方法。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token punctuation">[</span>ar1<span class="token punctuation">,</span><span class="token operator">...</span>ar2<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
ar1<span class="token comment">//0</span>
ar2<span class="token comment">//[ 1, 2, 3 ]</span>

<span class="token keyword">let</span> <span class="token punctuation">[</span><span class="token operator">...</span>ar3<span class="token punctuation">,</span>ar4<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token comment">//SyntaxError: Rest element must be last element</span>
</code></pre></div><div class="warning custom-block"><p class="custom-block-title">WARNING</p> <p>扩展运算符只能用在最后一项。</p></div> <h4 id="用于函数参数"><a href="#用于函数参数" aria-hidden="true" class="header-anchor">#</a> 用于函数参数</h4> <p>除了为数组赋值，还支持作为函数参数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> a<span class="token operator">+</span>b
<span class="token punctuation">}</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">...</span>arr<span class="token punctuation">)</span><span class="token comment">//1</span>
</code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p> <p>任何含Iterator接口的对象都可以通过扩展运算符转为真正的数组。详情见<a href="#iterable%E6%8E%A5%E5%8F%A3">iterable接口</a>。</p></div> <h3 id="_5"><a href="#_5" aria-hidden="true" class="header-anchor">#</a> 5 + - * /</h3> <p>可以用于各种类型间的运算。</p> <h3 id="_6"><a href="#_6" aria-hidden="true" class="header-anchor">#</a> 6 []</h3> <p>最常用的是表示数组<code>[1,2,3]</code>与数组下标<code>arr[1]</code>，也可以作为对象的属性名<code>obj['key']</code>，支持使用变量作为属性名<code>obj[key]</code>（key不仅可以是符合规则的字符串，也可以是Symbol）。</p> <h3 id="_7"><a href="#_7" aria-hidden="true" class="header-anchor">#</a> 7 .</h3> <p>点运算符的功能是[]的子集，当属性名为常量时可以用于设置、获取对象属性<code>obj.key</code>。</p> <h2 id="关键字"><a href="#关键字" aria-hidden="true" class="header-anchor">#</a> 关键字</h2> <h3 id="new"><a href="#new" aria-hidden="true" class="header-anchor">#</a> new</h3> <p>从构造函数派生出对象，构造函数的this指向创建的对象。</p> <h3 id="delete"><a href="#delete" aria-hidden="true" class="header-anchor">#</a> delete</h3> <p>用于删除对象属性，不可用于删除对象。</p> <h2 id="循环体"><a href="#循环体" aria-hidden="true" class="header-anchor">#</a> 循环体</h2> <h3 id="array-foreach"><a href="#array-foreach" aria-hidden="true" class="header-anchor">#</a> Array.forEach</h3> <p><code>Array.forEach(function(currentValue, index, arr), thisValue)</code></p> <p>由于是以传入函数的形式遍历，forEach无法使用return从外部函数体返回，由于是数组的一种方法，也不支持break跳出循环。</p> <h3 id="for…in"><a href="#for…in" aria-hidden="true" class="header-anchor">#</a> for…in</h3> <p><code>for(let item in obj)</code></p> <p>for…in支持遍历各种对象，它的item是对象的key，总是string类型。这种方法不稳定，不同时候结果的顺序可能不一致。如果用于数组，还有一个问题是所有属性也包括数组元素以外的自定义属性。</p> <h3 id="for…of"><a href="#for…of" aria-hidden="true" class="header-anchor">#</a> for…of</h3> <p><code>for(let item of obj)</code></p> <p>首先，它没有for…in的缺点，其次，也没有forEach的缺点。for…of支持数组、字符串、Set、Map和其他有iterable接口的对象，但不支持普通对象（会提示<code>is not iterable</code>）。</p> <h3 id="iterable接口"><a href="#iterable接口" aria-hidden="true" class="header-anchor">#</a> iterable接口</h3> <p>对象的<code>[Symbol.iterator]</code>属性指向其默认的遍历器。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> myIterable <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
myIterable<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">yield</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">yield</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">yield</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">[</span><span class="token operator">...</span>myIterable<span class="token punctuation">]</span><span class="token comment">//[ 1, 2, 3 ]</span>
</code></pre></div><h2 id="内置对象"><a href="#内置对象" aria-hidden="true" class="header-anchor">#</a> 内置对象</h2> <h3 id="math"><a href="#math" aria-hidden="true" class="header-anchor">#</a> Math</h3> <h2 id="函数简介"><a href="#函数简介" aria-hidden="true" class="header-anchor">#</a> 函数简介</h2> <p>普通函数都是Function对象的实例，而构造函数生成的函数是Object的实例。相比普通对象，函数多了可被调用的特征。</p> <div class="tip custom-block"><p class="custom-block-title">'Function'与‘function’的不同</p> <p>‘Function’是JS的内置对象，而'function'是一个声明函数的关键字。</p></div> <div class="tip custom-block"><p class="custom-block-title">和其他语言函数的区别</p> <p>由于JS是弱类型语言，函数无法指定形参类型与返回类型，同时也无法限制传入参数的个数，因此没有重载的特性。函数内部可以通过<strong>arguments对象</strong>获取实参。</p></div> <h2 id="this"><a href="#this" aria-hidden="true" class="header-anchor">#</a> this</h2> <p>this指向调用当前函数的对象，如果没有对象调用，那么this==window。在箭头函数中，this指向与环境中相同。bind、call、reply方法都可以修改this。</p> <h3 id="绑定this"><a href="#绑定this" aria-hidden="true" class="header-anchor">#</a> 绑定this</h3> <p>绑定this的4种方法，按优先级从低到高排序分别是默认绑定、隐式绑定、显式绑定、new绑定。其中apply()与call()属于显式绑定。</p> <h4 id="默认绑定"><a href="#默认绑定" aria-hidden="true" class="header-anchor">#</a> 默认绑定</h4> <p>全局环境中、函数独立调用时（即使被嵌套、包括立即执行函数），this指向window。有时候被嵌套的函数想获得上层函数的this，可以使用<code>var that = this</code>语句传递this值。</p> <h4 id="隐式绑定-方法调用"><a href="#隐式绑定-方法调用" aria-hidden="true" class="header-anchor">#</a> 隐式绑定/方法调用</h4> <p>this的值是调用该函数的对象。如a.b()中b内部的this指向a。只有直接调用<code>obj.func()</code>时才会传递this，否则this仍指向window。函数虽然可以属于一个对象，但函数不会与对象绑定this。</p> <p>这些不能传递this的场景包括赋值、传参、内置函数（如setTimeout）、间接引用（对象的属性赋值时的立即执行函数，如<code>(p.foo = o.foo)()</code>，this为window）等。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> val<span class="token operator">=</span><span class="token string">'window'</span>
<span class="token keyword">var</span> <span class="token function-variable function">func</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>val<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> obj<span class="token operator">=</span><span class="token punctuation">{</span>val<span class="token punctuation">:</span><span class="token string">'obj'</span><span class="token punctuation">,</span>func<span class="token punctuation">:</span>func<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//window</span>
obj<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//obj</span>

<span class="token comment">//赋值会丢失this</span>
<span class="token keyword">var</span> func1 <span class="token operator">=</span> obj<span class="token punctuation">.</span>func
<span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//window</span>

<span class="token comment">//作为参数传递也会丢失this</span>
<span class="token keyword">var</span> <span class="token function-variable function">func2</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">func</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">func2</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>func<span class="token punctuation">)</span><span class="token comment">//window</span>
</code></pre></div><h4 id="显示绑定"><a href="#显示绑定" aria-hidden="true" class="header-anchor">#</a> 显示绑定</h4> <p>即使用call、apply、bind方法绑定this到对象上。JS还新增了许多内置函数提供thisValue选项，如数组的迭代方法map、forEach、filter、some、every。</p> <h4 id="new绑定"><a href="#new绑定" aria-hidden="true" class="header-anchor">#</a> new绑定</h4> <p>new的作用是从构造函数返回新对象。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">constructorA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token operator">=</span><span class="token number">0</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">constructorA</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
obj<span class="token punctuation">.</span>a<span class="token comment">//0</span>
</code></pre></div><p>需要注意如果constructor没有返回值，那么构造的对象就是返回值。而其中的this永远指向obj，即新生成的对象，即使<code>let newObj = new obj.constructorA()</code>，this也会指向newObj，而不是obj。</p> <h3 id="this与函数"><a href="#this与函数" aria-hidden="true" class="header-anchor">#</a> this与函数</h3> <p>this的四种绑定方法其实也对应函数的四种调用方式，包括函数调用(func)、方法调用（obj.func）、间接调用（call、apply）、构造函数调用（new）。</p> <h3 id="实现bind"><a href="#实现bind" aria-hidden="true" class="header-anchor">#</a> 实现bind</h3> <p><code>function.bind(thisArg[,arg1[,arg2[,...]]])</code></p> <p>bind提供了两个功能，一个是传递this，另一个是传递参数（之后传参数会位于这些参数后面），它返回绑定后的函数。</p> <p>首先，我们要传递this，需要通过方法调用来完成，bind的this是原函数，我们要怎么返回绑定好的函数呢？🤔</p> <p>可以想到，我们先把函数绑定到那个环境上去，但这就是bind的功能啊。实际上，我们应该返回一个全新函数，而这个新函数的执行结果与原函数+thisArg一致。</p> <p>那么先不考虑传递参数，只考虑this的情况。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myBind</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">thisValue</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  thisValue<span class="token punctuation">.</span>_func <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> thisValue<span class="token punctuation">.</span><span class="token function">_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样我们就已经实现了bind最基本的功能——绑定this，但我们向thisValue添加了属性。其实我们只用保证结果正确，因此可以删除添加的属性，用临时变量替代。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myBind</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">thisValue</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">let</span> func <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token keyword">let</span> <span class="token function-variable function">getResult</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span>thisValue</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    thisValue<span class="token punctuation">.</span>_func <span class="token operator">=</span> func
    <span class="token keyword">let</span> result <span class="token operator">=</span> thisValue<span class="token punctuation">.</span><span class="token function">_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">delete</span> thisValue<span class="token punctuation">.</span>_func
    <span class="token keyword">return</span> result
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">getResult</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span>thisValue<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>细心的朋友不难看出，getResult和call、apply有着相似的功能，即返回绑定某个this值后的执行结果。也就是说，bind其实是基于call和apply实现的。但为了方便理解整个概念，我先介绍了bind。</p> <h4 id="call和apply"><a href="#call和apply" aria-hidden="true" class="header-anchor">#</a> call和apply</h4> <p>明白了基本原理之后，我们来研究如何传入参数。首先，我们应该知道所有参数都可以在aruguments对象中找到，我们先看一下它的结构：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">printArguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> arguments<span class="token punctuation">}</span>
<span class="token function">printArguments</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token comment">//[Arguments] { '0': 1, '1': 2, '2': 3 }</span>
</code></pre></div><p>Arguments是一个特殊的对象，它不是数组，但具有数组的许多特征，这里把它当作数组。</p> <p>先看<code>function.call(thisArg,arg1,arg2,...)</code>，我们需要把后面的参数传入函数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myCall</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">let</span> <span class="token punctuation">[</span>thisValue<span class="token punctuation">,</span><span class="token operator">...</span>parameters<span class="token punctuation">]</span> <span class="token operator">=</span> arguments
  thisValue<span class="token punctuation">.</span>_func <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> thisValue<span class="token punctuation">.</span><span class="token function">_func</span><span class="token punctuation">(</span><span class="token operator">...</span>parameters<span class="token punctuation">)</span>
  <span class="token keyword">delete</span> thisValue<span class="token punctuation">.</span>_func
  <span class="token keyword">return</span> result
<span class="token punctuation">}</span>
</code></pre></div><p>再看看<code>function.apply(thisArg,[argsArray])</code>，我们转换一下参数形式就行。需要注意我们的argsArray不能为空，如果为空，parameters为undefined，再使用扩展运算符就会报错<code>is not iterable</code>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myApply</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">let</span> <span class="token punctuation">[</span>thisValue<span class="token punctuation">,</span>parameters<span class="token punctuation">]</span> <span class="token operator">=</span> arguments
  thisValue<span class="token punctuation">.</span>_func <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> thisValue<span class="token punctuation">.</span><span class="token function">_func</span><span class="token punctuation">(</span><span class="token operator">...</span>parameters<span class="token punctuation">)</span>
  <span class="token keyword">delete</span> thisValue<span class="token punctuation">.</span>_func
  <span class="token keyword">return</span> result
<span class="token punctuation">}</span>
</code></pre></div><h4 id="可以完善的一些地方"><a href="#可以完善的一些地方" aria-hidden="true" class="header-anchor">#</a> 可以完善的一些地方</h4> <p>如果没有传this值，我们可以让默认值为window，如果没有传argsArray，让默认值为[]，这里拿apply作为例子。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myApply</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">let</span> <span class="token punctuation">[</span>thisValue<span class="token punctuation">,</span>parameters<span class="token punctuation">]</span> <span class="token operator">=</span> arguments
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>thisValue<span class="token punctuation">)</span>thisValue <span class="token operator">=</span> window
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>parameters<span class="token punctuation">)</span>parameters <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  thisValue<span class="token punctuation">.</span>_func <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> thisValue<span class="token punctuation">.</span><span class="token function">_func</span><span class="token punctuation">(</span><span class="token operator">...</span>parameters<span class="token punctuation">)</span>
  <span class="token keyword">delete</span> thisValue<span class="token punctuation">.</span>_func
  <span class="token keyword">return</span> result
<span class="token punctuation">}</span>
</code></pre></div><p>我们的bind也可以改造成使用apply的模式。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myBind</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">let</span> func <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token keyword">let</span> <span class="token punctuation">[</span>thisValue<span class="token punctuation">,</span><span class="token operator">...</span>parameters<span class="token punctuation">]</span> <span class="token operator">=</span> arguments
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> func<span class="token punctuation">.</span><span class="token function">myApply</span><span class="token punctuation">(</span>thisValue<span class="token punctuation">,</span>parameters<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在还可以继续考虑两个问题：如果不能使用…运算符怎么办？如果绑定的对象已经有了_func属性或者不能设置属性怎么办？</p> <p>先看如何替代…运算符。如果不能使用…运算符，我们就不能方便地向函数传递任意多个参数，可以使用eval()解析生成的字符串，也可以用<code>new Function([arg1[,arg2[,...argN]],]functionBody)</code>结合读取arguments数组读取任意多个参数，也是通过解析生成的字符串。</p> <p>使用不重复的属性。ES6提供了symbol()用于标志唯一的事物，它可以以作为对象的属性，我们仍以apply作为例子。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myApply</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">let</span> <span class="token punctuation">[</span>thisValue<span class="token punctuation">,</span>parameters<span class="token punctuation">]</span> <span class="token operator">=</span> arguments
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>thisValue<span class="token punctuation">)</span>thisValue <span class="token operator">=</span> window
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>parameters<span class="token punctuation">)</span>parameters <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">let</span> _func <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  thisValue<span class="token punctuation">[</span>_func<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> thisValue<span class="token punctuation">[</span>_func<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">...</span>parameters<span class="token punctuation">)</span>
  <span class="token keyword">delete</span> thisValue<span class="token punctuation">[</span>_func<span class="token punctuation">]</span>
  <span class="token keyword">return</span> result
<span class="token punctuation">}</span>
</code></pre></div><p>此外还可以用Math.random()生成一个不太可能重复的属性名。</p> <h2 id="作用域-scope"><a href="#作用域-scope" aria-hidden="true" class="header-anchor">#</a> 作用域 Scope</h2> <p>作用域即变量和函数的可访问范围和生命周期。</p> <h3 id="变量作用域"><a href="#变量作用域" aria-hidden="true" class="header-anchor">#</a> 变量作用域</h3> <p>可以分为全局作用域、函数内作用域（包括嵌套函数）、块级作用域。局部变量可以在局部覆盖同名全局变量。</p> <h3 id="作用域链-scope-chain"><a href="#作用域链-scope-chain" aria-hidden="true" class="header-anchor">#</a> 作用域链 Scope Chain</h3> <p>作用域链决定了函数能访问变量的范围，组织了访问变量的顺序，在解析标识符时一级一级地按顺序查找函数和变量。需要注意的是，JS根据函数定义的位置查找，而非执行的位置。</p> <h4 id="执行环境-执行上下文-execution-context"><a href="#执行环境-执行上下文-execution-context" aria-hidden="true" class="header-anchor">#</a> 执行环境/执行上下文 Execution Context</h4> <p>执行环境定义了变量与函数能访问的数据，包括全局、函数内、eval、块级作用域等。</p> <p>执行环境包括至少3个重要的属性：作用域链、变量对象和this（按创建顺序排序）。这里关注前两个。</p> <h4 id="变量对象-variable-object"><a href="#变量对象-variable-object" aria-hidden="true" class="header-anchor">#</a> 变量对象 Variable Object</h4> <p>每个执行环境都有与之关联的变量对象，它包括了环境中所有的变量和函数。全剧环境下的变量对象称为VO。</p> <p>所有的变量和函数即函数声明、变量声明、函数形参。不包括匿名函数。</p> <h4 id="活动对象-activation-object"><a href="#活动对象-activation-object" aria-hidden="true" class="header-anchor">#</a> 活动对象 Activation Object</h4> <p>当环境是函数时，活动对象就是变量对象。活动对象至少包含arguments对象（即函数参数）。有很多资料提到函数中不能直接访问VO，而以AO替代，不过反正这两个都是不能用JS代码打印出来的。</p> <p>Arguments对象至少包括callee（对当前函数的引用）、length（真正传递参数的个数）、properties-indexs（函数的参数值），注意Arguments并不包含this。</p> <h4 id="作用域链"><a href="#作用域链" aria-hidden="true" class="header-anchor">#</a> 作用域链</h4> <p>从外层到函数乃至嵌套函数内，多个执行环境形成了一个程序执行栈，同时也形成了一个指向多个环境的链表，即作用域链。</p> <p>作用域链包括VO与所有上级的作用域。</p> <h2 id="数组方法"><a href="#数组方法" aria-hidden="true" class="header-anchor">#</a> 数组方法</h2> <h3 id="map"><a href="#map" aria-hidden="true" class="header-anchor">#</a> map</h3> <p><code>array.map(function(currentValue,index,arr),thisValue)</code></p> <p>map的作用是按回调函数的规则从原数组映射出一个新数组（作为返回值）。</p> <p>从函数原型可以看出，回调函数可以得到当前元素的值、索引、原数组，处理后的值应作为返回值，还能传入this对象。</p> <p>currentValue和index以及arr是只读的，但arr是对象，currentValue也可能是对象，此时可以修改属性或执行方法。</p> <h3 id="every"><a href="#every" aria-hidden="true" class="header-anchor">#</a> every</h3> <h3 id="some"><a href="#some" aria-hidden="true" class="header-anchor">#</a> some</h3> <h3 id="foreach"><a href="#foreach" aria-hidden="true" class="header-anchor">#</a> forEach</h3> <h3 id="reduce"><a href="#reduce" aria-hidden="true" class="header-anchor">#</a> reduce</h3> <h3 id="push、pop"><a href="#push、pop" aria-hidden="true" class="header-anchor">#</a> push、pop</h3> <h3 id="shift、unshift"><a href="#shift、unshift" aria-hidden="true" class="header-anchor">#</a> shift、unshift</h3> <h3 id="slice"><a href="#slice" aria-hidden="true" class="header-anchor">#</a> slice</h3> <h3 id="indexof"><a href="#indexof" aria-hidden="true" class="header-anchor">#</a> indexOf</h3> <h3 id="sort"><a href="#sort" aria-hidden="true" class="header-anchor">#</a> sort</h3> <h3 id="reverse"><a href="#reverse" aria-hidden="true" class="header-anchor">#</a> reverse</h3> <h3 id="splice"><a href="#splice" aria-hidden="true" class="header-anchor">#</a> splice</h3> <h3 id="concat"><a href="#concat" aria-hidden="true" class="header-anchor">#</a> concat</h3> <h3 id="join"><a href="#join" aria-hidden="true" class="header-anchor">#</a> join</h3> <h3 id="tostring"><a href="#tostring" aria-hidden="true" class="header-anchor">#</a> toString</h3> <h2 id="对象方法"><a href="#对象方法" aria-hidden="true" class="header-anchor">#</a> 对象方法</h2> <h3 id="object-assign"><a href="#object-assign" aria-hidden="true" class="header-anchor">#</a> Object.assign()</h3> <h2 id="string方法"><a href="#string方法" aria-hidden="true" class="header-anchor">#</a> String方法</h2> <h3 id="substring"><a href="#substring" aria-hidden="true" class="header-anchor">#</a> substring</h3> <h3 id="split"><a href="#split" aria-hidden="true" class="header-anchor">#</a> split</h3> <h2 id="参考"><a href="#参考" aria-hidden="true" class="header-anchor">#</a> 参考</h2> <h3 id="模板字符串"><a href="#模板字符串" aria-hidden="true" class="header-anchor">#</a> 模板字符串</h3> <p>`我买了${a}箱苹果``</p> <h3 id="变量作用域-2"><a href="#变量作用域-2" aria-hidden="true" class="header-anchor">#</a> 变量作用域</h3> <p>JS中变量的作用域可以是全局，也可以是局部（函数参数和局部变量），同名局部变量会</p> <h4 id="函数作用域"><a href="#函数作用域" aria-hidden="true" class="header-anchor">#</a> 函数作用域</h4> <p>JS的函数作用域是指在函数内声明的变量始终可见（变量提升）。</p> <h5 id="作用域链-2"><a href="#作用域链-2" aria-hidden="true" class="header-anchor">#</a> 作用域链</h5> <p>JS查找上级作用域时，根据定义的位置查找，与执行环境无关。</p> <h2 id="参考目录"><a href="#参考目录" aria-hidden="true" class="header-anchor">#</a> 参考目录</h2> <p>this</p> <p>https://www.cnblogs.com/xiaohuochai/p/5735901.html</p> <p>JavaScript</p> <p>https://www.liaoxuefeng.com/wiki/1022910821149312</p> <p>ECMA Script 6</p> <p>http://es6.ruanyifeng.com/</p> <p>Execution Context</p> <p>https://juejin.im/entry/58edde2761ff4b00581b93ff</p> <p>Symbol</p> <p>https://www.cnblogs.com/diligenceday/p/5462733.html</p></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/NTT-Frontend-Navigation.github.io/assets/js/app.829b5ce9.js" defer></script><script src="/NTT-Frontend-Navigation.github.io/assets/js/3.8cef8892.js" defer></script>
  </body>
</html>
